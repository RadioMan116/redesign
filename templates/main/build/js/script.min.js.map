{"version":3,"sources":["imask.min.js","jquery.matchHeight-min.js","lazysizes.min.js","slideout.min.js","popup/popup.min.js","fontloader.js","map.js","script.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC51EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjCA;AACA;AACA;ACFA;AACA;ACDA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"script.min.js","sourcesContent":["/*!\r\n* jquery.inputmask.bundle.js\r\n* https://github.com/RobinHerbots/Inputmask\r\n* Copyright (c) 2010 - 2018 Robin Herbots\r\n* Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)\r\n* Version: 4.0.1-beta.4\r\n*/\r\n\r\n!function(modules) {\r\n    var installedModules = {};\r\n    function __webpack_require__(moduleId) {\r\n        if (installedModules[moduleId]) return installedModules[moduleId].exports;\r\n        var module = installedModules[moduleId] = {\r\n            i: moduleId,\r\n            l: !1,\r\n            exports: {}\r\n        };\r\n        return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), \r\n        module.l = !0, module.exports;\r\n    }\r\n    __webpack_require__.m = modules, __webpack_require__.c = installedModules, __webpack_require__.d = function(exports, name, getter) {\r\n        __webpack_require__.o(exports, name) || Object.defineProperty(exports, name, {\r\n            configurable: !1,\r\n            enumerable: !0,\r\n            get: getter\r\n        });\r\n    }, __webpack_require__.r = function(exports) {\r\n        Object.defineProperty(exports, \"__esModule\", {\r\n            value: !0\r\n        });\r\n    }, __webpack_require__.n = function(module) {\r\n        var getter = module && module.__esModule ? function() {\r\n            return module.default;\r\n        } : function() {\r\n            return module;\r\n        };\r\n        return __webpack_require__.d(getter, \"a\", getter), getter;\r\n    }, __webpack_require__.o = function(object, property) {\r\n        return Object.prototype.hasOwnProperty.call(object, property);\r\n    }, __webpack_require__.p = \"\", __webpack_require__(__webpack_require__.s = 0);\r\n}([ function(module, exports, __webpack_require__) {\r\n    \"use strict\";\r\n    __webpack_require__(1), __webpack_require__(7), __webpack_require__(8), __webpack_require__(9);\r\n    var _inputmask2 = _interopRequireDefault(__webpack_require__(4)), _inputmask4 = _interopRequireDefault(__webpack_require__(2)), _jquery2 = _interopRequireDefault(__webpack_require__(3));\r\n    function _interopRequireDefault(obj) {\r\n        return obj && obj.__esModule ? obj : {\r\n            default: obj\r\n        };\r\n    }\r\n    _inputmask4.default === _jquery2.default && __webpack_require__(10), window.Inputmask = _inputmask2.default;\r\n}, function(module, exports, __webpack_require__) {\r\n    \"use strict\";\r\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\r\n    \"function\" == typeof Symbol && Symbol.iterator;\r\n    __WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(2), __webpack_require__(4) ], \r\n    void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = \"function\" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = function($, Inputmask) {\r\n        var formatCode = {\r\n            d: [ \"[1-9]|[12][0-9]|3[01]\", Date.prototype.setDate, \"day\", Date.prototype.getDate ],\r\n            dd: [ \"0[1-9]|[12][0-9]|3[01]\", Date.prototype.setDate, \"day\", function() {\r\n                return pad(Date.prototype.getDate.call(this), 2);\r\n            } ],\r\n            ddd: [ \"\" ],\r\n            dddd: [ \"\" ],\r\n            m: [ \"[1-9]|1[012]\", Date.prototype.setMonth, \"month\", function() {\r\n                return Date.prototype.getMonth.call(this) + 1;\r\n            } ],\r\n            mm: [ \"0[1-9]|1[012]\", Date.prototype.setMonth, \"month\", function() {\r\n                return pad(Date.prototype.getMonth.call(this) + 1, 2);\r\n            } ],\r\n            mmm: [ \"\" ],\r\n            mmmm: [ \"\" ],\r\n            yy: [ \"[0-9]{2}\", Date.prototype.setFullYear, \"year\", function() {\r\n                return pad(Date.prototype.getFullYear.call(this), 2);\r\n            } ],\r\n            yyyy: [ \"[0-9]{4}\", Date.prototype.setFullYear, \"year\", function() {\r\n                return pad(Date.prototype.getFullYear.call(this), 4);\r\n            } ],\r\n            h: [ \"[1-9]|1[0-2]\", Date.prototype.setHours, \"hours\", Date.prototype.getHours ],\r\n            hh: [ \"0[1-9]|1[0-2]\", Date.prototype.setHours, \"hours\", function() {\r\n                return pad(Date.prototype.getHours.call(this), 2);\r\n            } ],\r\n            hhh: [ \"[0-9]+\", Date.prototype.setHours, \"hours\", Date.prototype.getHours ],\r\n            H: [ \"1?[0-9]|2[0-3]\", Date.prototype.setHours, \"hours\", Date.prototype.getHours ],\r\n            HH: [ \"[01][0-9]|2[0-3]\", Date.prototype.setHours, \"hours\", function() {\r\n                return pad(Date.prototype.getHours.call(this), 2);\r\n            } ],\r\n            HHH: [ \"[0-9]+\", Date.prototype.setHours, \"hours\", Date.prototype.getHours ],\r\n            M: [ \"[1-5]?[0-9]\", Date.prototype.setMinutes, \"minutes\", Date.prototype.getMinutes ],\r\n            MM: [ \"[0-5][0-9]\", Date.prototype.setMinutes, \"minutes\", function() {\r\n                return pad(Date.prototype.getMinutes.call(this), 2);\r\n            } ],\r\n            s: [ \"[1-5]?[0-9]\", Date.prototype.setSeconds, \"seconds\", Date.prototype.getSeconds ],\r\n            ss: [ \"[0-5][0-9]\", Date.prototype.setSeconds, \"seconds\", function() {\r\n                return pad(Date.prototype.getSeconds.call(this), 2);\r\n            } ],\r\n            l: [ \"[0-9]{3}\", Date.prototype.setMilliseconds, \"milliseconds\", function() {\r\n                return pad(Date.prototype.getMilliseconds.call(this), 3);\r\n            } ],\r\n            L: [ \"[0-9]{2}\", Date.prototype.setMilliseconds, \"milliseconds\", function() {\r\n                return pad(Date.prototype.getMilliseconds.call(this), 2);\r\n            } ],\r\n            t: [ \"[ap]\" ],\r\n            tt: [ \"[ap]m\" ],\r\n            T: [ \"[AP]\" ],\r\n            TT: [ \"[AP]M\" ],\r\n            Z: [ \"\" ],\r\n            o: [ \"\" ],\r\n            S: [ \"\" ]\r\n        }, formatAlias = {\r\n            isoDate: \"yyyy-mm-dd\",\r\n            isoTime: \"HH:MM:ss\",\r\n            isoDateTime: \"yyyy-mm-dd'T'HH:MM:ss\",\r\n            isoUtcDateTime: \"UTC:yyyy-mm-dd'T'HH:MM:ss'Z'\"\r\n        };\r\n        function getTokenizer(opts) {\r\n            if (!opts.tokenizer) {\r\n                var tokens = [];\r\n                for (var ndx in formatCode) -1 === tokens.indexOf(ndx[0]) && tokens.push(ndx[0]);\r\n                opts.tokenizer = \"(\" + tokens.join(\"+|\") + \")+?|.\", opts.tokenizer = new RegExp(opts.tokenizer, \"g\");\r\n            }\r\n            return opts.tokenizer;\r\n        }\r\n        function parse(format, dateObjValue, opts) {\r\n            for (var match, mask = \"\"; match = getTokenizer(opts).exec(format); ) if (void 0 === dateObjValue) if (formatCode[match[0]]) mask += \"(\" + formatCode[match[0]][0] + \")\"; else switch (match[0]) {\r\n              case \"[\":\r\n                mask += \"(\";\r\n                break;\r\n\r\n              case \"]\":\r\n                mask += \")?\";\r\n                break;\r\n\r\n              default:\r\n                mask += Inputmask.escapeRegex(match[0]);\r\n            } else if (formatCode[match[0]]) {\r\n                var getFn = formatCode[match[0]][3];\r\n                mask += getFn.call(dateObjValue.date);\r\n            } else mask += match[0];\r\n            return mask;\r\n        }\r\n        function pad(val, len) {\r\n            for (val = String(val), len = len || 2; val.length < len; ) val = \"0\" + val;\r\n            return val;\r\n        }\r\n        function analyseMask(maskString, format, opts) {\r\n            var targetProp, match, dateOperation, targetValidator, dateObj = {\r\n                date: new Date(1, 0, 1)\r\n            }, mask = maskString;\r\n            function extendProperty(value) {\r\n                var correctedValue;\r\n                if (opts.min && opts.min[targetProp] || opts.max && opts.max[targetProp]) {\r\n                    var min = opts.min && opts.min[targetProp] || opts.max[targetProp], max = opts.max && opts.max[targetProp] || opts.min[targetProp];\r\n                    for (correctedValue = value.replace(/[^0-9]/g, \"\"), correctedValue += (min.indexOf(correctedValue) < max.indexOf(correctedValue) ? max : min).toString().substr(correctedValue.length); !new RegExp(targetValidator).test(correctedValue); ) correctedValue--;\r\n                } else correctedValue = value.replace(/[^0-9]/g, \"0\");\r\n                return correctedValue;\r\n            }\r\n            function setValue(dateObj, value, opts) {\r\n                dateObj[targetProp] = extendProperty(value), dateObj[\"raw\" + targetProp] = value, \r\n                void 0 !== dateOperation && dateOperation.call(dateObj.date, \"month\" == targetProp ? parseInt(dateObj[targetProp]) - 1 : dateObj[targetProp]);\r\n            }\r\n            if (\"string\" == typeof mask) {\r\n                for (;match = getTokenizer(opts).exec(format); ) {\r\n                    var value = mask.slice(0, match[0].length);\r\n                    formatCode.hasOwnProperty(match[0]) && (targetValidator = formatCode[match[0]][0], \r\n                    targetProp = formatCode[match[0]][2], dateOperation = formatCode[match[0]][1], setValue(dateObj, value)), \r\n                    mask = mask.slice(value.length);\r\n                }\r\n                return dateObj;\r\n            }\r\n        }\r\n        return Inputmask.extendAliases({\r\n            datetime: {\r\n                mask: function(opts) {\r\n                    return formatCode.S = opts.i18n.ordinalSuffix.join(\"|\"), opts.inputFormat = formatAlias[opts.inputFormat] || opts.inputFormat, \r\n                    opts.displayFormat = formatAlias[opts.displayFormat] || opts.displayFormat || opts.inputFormat, \r\n                    opts.outputFormat = formatAlias[opts.outputFormat] || opts.outputFormat || opts.inputFormat, \r\n                    opts.placeholder = \"\" !== opts.placeholder ? opts.placeholder : opts.inputFormat.replace(/[\\[\\]]/, \"\"), \r\n                    opts.min = analyseMask(opts.min, opts.inputFormat, opts), opts.max = analyseMask(opts.max, opts.inputFormat, opts), \r\n                    opts.regex = parse(opts.inputFormat, void 0, opts), null;\r\n                },\r\n                placeholder: \"\",\r\n                inputFormat: \"isoDateTime\",\r\n                displayFormat: void 0,\r\n                outputFormat: void 0,\r\n                min: null,\r\n                max: null,\r\n                i18n: {\r\n                    dayNames: [ \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\" ],\r\n                    monthNames: [ \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\" ],\r\n                    ordinalSuffix: [ \"st\", \"nd\", \"rd\", \"th\" ]\r\n                },\r\n                postValidation: function(buffer, currentResult, opts) {\r\n                    var result = currentResult, dateParts = analyseMask(buffer.join(\"\"), opts.inputFormat, opts);\r\n                    return result && dateParts.date.getTime() == dateParts.date.getTime() && (result = (result = function(dateParts, currentResult) {\r\n                        return (!isFinite(dateParts.rawday) || \"29\" == dateParts.day && !isFinite(dateParts.rawyear) || new Date(dateParts.date.getFullYear(), isFinite(dateParts.rawmonth) ? dateParts.month : dateParts.date.getMonth() + 1, 0).getDate() >= dateParts.day) && currentResult;\r\n                    }(dateParts, result)) && function(dateParts, opts) {\r\n                        var result = !0;\r\n                        if (opts.min) {\r\n                            if (dateParts.rawyear) {\r\n                                var rawYear = dateParts.rawyear.replace(/[^0-9]/g, \"\"), minYear = opts.min.year.substr(0, rawYear.length);\r\n                                result = minYear <= rawYear;\r\n                            }\r\n                            dateParts.year === dateParts.rawyear && opts.min.date.getTime() == opts.min.date.getTime() && (result = opts.min.date.getTime() <= dateParts.date.getTime());\r\n                        }\r\n                        return result && opts.max && opts.max.date.getTime() == opts.max.date.getTime() && (result = opts.max.date.getTime() >= dateParts.date.getTime()), \r\n                        result;\r\n                    }(dateParts, opts)), result;\r\n                },\r\n                onKeyDown: function(e, buffer, caretPos, opts) {\r\n                    if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {\r\n                        for (var match, today = new Date(), date = \"\"; match = getTokenizer(opts).exec(opts.inputFormat); ) \"d\" === match[0].charAt(0) ? date += pad(today.getDate(), match[0].length) : \"m\" === match[0].charAt(0) ? date += pad(today.getMonth() + 1, match[0].length) : \"yyyy\" === match[0] ? date += today.getFullYear().toString() : \"y\" === match[0].charAt(0) && (date += pad(today.getYear(), match[0].length));\r\n                        this.inputmask._valueSet(date), $(this).trigger(\"setvalue\");\r\n                    }\r\n                },\r\n                onUnMask: function(maskedValue, unmaskedValue, opts) {\r\n                    return parse(opts.outputFormat, analyseMask(maskedValue, opts.inputFormat, opts), opts);\r\n                },\r\n                casing: function(elem, test, pos, validPositions) {\r\n                    return 0 == test.nativeDef.indexOf(\"[ap]\") ? elem.toLowerCase() : 0 == test.nativeDef.indexOf(\"[AP]\") ? elem.toUpperCase() : elem;\r\n                },\r\n                insertMode: !1\r\n            }\r\n        }), Inputmask;\r\n    }) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);\r\n}, function(module, exports, __webpack_require__) {\r\n    \"use strict\";\r\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\r\n    \"function\" == typeof Symbol && Symbol.iterator;\r\n    __WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(3) ], void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = \"function\" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = function($) {\r\n        return $;\r\n    }) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);\r\n}, function(module, exports) {\r\n    module.exports = jQuery;\r\n}, function(module, exports, __webpack_require__) {\r\n    \"use strict\";\r\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__, _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\r\n        return typeof obj;\r\n    } : function(obj) {\r\n        return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\r\n    };\r\n    __WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(2), __webpack_require__(5), __webpack_require__(6) ], \r\n    void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = \"function\" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = function($, window, document, undefined) {\r\n        var ua = navigator.userAgent, mobile = isInputEventSupported(\"touchstart\"), iemobile = /iemobile/i.test(ua), iphone = /iphone/i.test(ua) && !iemobile;\r\n        function Inputmask(alias, options, internal) {\r\n            if (!(this instanceof Inputmask)) return new Inputmask(alias, options, internal);\r\n            this.el = undefined, this.events = {}, this.maskset = undefined, this.refreshValue = !1, \r\n            !0 !== internal && ($.isPlainObject(alias) ? options = alias : (options = options || {}, \r\n            alias && (options.alias = alias)), this.opts = $.extend(!0, {}, this.defaults, options), \r\n            this.noMasksCache = options && options.definitions !== undefined, this.userOptions = options || {}, \r\n            this.isRTL = this.opts.numericInput, resolveAlias(this.opts.alias, options, this.opts));\r\n        }\r\n        function resolveAlias(aliasStr, options, opts) {\r\n            var aliasDefinition = Inputmask.prototype.aliases[aliasStr];\r\n            return aliasDefinition ? (aliasDefinition.alias && resolveAlias(aliasDefinition.alias, undefined, opts), \r\n            $.extend(!0, opts, aliasDefinition), $.extend(!0, opts, options), !0) : (null === opts.mask && (opts.mask = aliasStr), \r\n            !1);\r\n        }\r\n        function generateMaskSet(opts, nocache) {\r\n            function generateMask(mask, metadata, opts) {\r\n                var regexMask = !1;\r\n                if (null !== mask && \"\" !== mask || ((regexMask = null !== opts.regex) ? mask = (mask = opts.regex).replace(/^(\\^)(.*)(\\$)$/, \"$2\") : (regexMask = !0, \r\n                mask = \".*\")), 1 === mask.length && !1 === opts.greedy && 0 !== opts.repeat && (opts.placeholder = \"\"), \r\n                opts.repeat > 0 || \"*\" === opts.repeat || \"+\" === opts.repeat) {\r\n                    var repeatStart = \"*\" === opts.repeat ? 0 : \"+\" === opts.repeat ? 1 : opts.repeat;\r\n                    mask = opts.groupmarker[0] + mask + opts.groupmarker[1] + opts.quantifiermarker[0] + repeatStart + \",\" + opts.repeat + opts.quantifiermarker[1];\r\n                }\r\n                var masksetDefinition, maskdefKey = regexMask ? \"regex_\" + opts.regex : opts.numericInput ? mask.split(\"\").reverse().join(\"\") : mask;\r\n                return Inputmask.prototype.masksCache[maskdefKey] === undefined || !0 === nocache ? (masksetDefinition = {\r\n                    mask: mask,\r\n                    maskToken: Inputmask.prototype.analyseMask(mask, regexMask, opts),\r\n                    validPositions: {},\r\n                    _buffer: undefined,\r\n                    buffer: undefined,\r\n                    tests: {},\r\n                    excludes: {},\r\n                    metadata: metadata,\r\n                    maskLength: undefined\r\n                }, !0 !== nocache && (Inputmask.prototype.masksCache[maskdefKey] = masksetDefinition, \r\n                masksetDefinition = $.extend(!0, {}, Inputmask.prototype.masksCache[maskdefKey]))) : masksetDefinition = $.extend(!0, {}, Inputmask.prototype.masksCache[maskdefKey]), \r\n                masksetDefinition;\r\n            }\r\n            if ($.isFunction(opts.mask) && (opts.mask = opts.mask(opts)), $.isArray(opts.mask)) {\r\n                if (opts.mask.length > 1) {\r\n                    if (null === opts.keepStatic) {\r\n                        opts.keepStatic = \"auto\";\r\n                        for (var i = 0; i < opts.mask.length; i++) if (opts.mask[i].charAt(0) !== opts.mask[0].charAt(0)) {\r\n                            opts.keepStatic = !0;\r\n                            break;\r\n                        }\r\n                    }\r\n                    var altMask = opts.groupmarker[0];\r\n                    return $.each(opts.isRTL ? opts.mask.reverse() : opts.mask, function(ndx, msk) {\r\n                        altMask.length > 1 && (altMask += opts.groupmarker[1] + opts.alternatormarker + opts.groupmarker[0]), \r\n                        msk.mask === undefined || $.isFunction(msk.mask) ? altMask += msk : altMask += msk.mask;\r\n                    }), generateMask(altMask += opts.groupmarker[1], opts.mask, opts);\r\n                }\r\n                opts.mask = opts.mask.pop();\r\n            }\r\n            return opts.mask && opts.mask.mask !== undefined && !$.isFunction(opts.mask.mask) ? generateMask(opts.mask.mask, opts.mask, opts) : generateMask(opts.mask, opts.mask, opts);\r\n        }\r\n        function isInputEventSupported(eventName) {\r\n            var el = document.createElement(\"input\"), evName = \"on\" + eventName, isSupported = evName in el;\r\n            return isSupported || (el.setAttribute(evName, \"return;\"), isSupported = \"function\" == typeof el[evName]), \r\n            el = null, isSupported;\r\n        }\r\n        function maskScope(actionObj, maskset, opts) {\r\n            maskset = maskset || this.maskset, opts = opts || this.opts;\r\n            var undoValue, $el, maxLength, colorMask, inputmask = this, el = this.el, isRTL = this.isRTL, skipKeyPressEvent = !1, skipInputEvent = !1, ignorable = !1, mouseEnter = !1;\r\n            function getMaskTemplate(baseOnInput, minimalPos, includeMode, noJit, clearOptionalTail) {\r\n                var greedy = opts.greedy;\r\n                clearOptionalTail && (opts.greedy = !1), minimalPos = minimalPos || 0;\r\n                var ndxIntlzr, test, testPos, maskTemplate = [], pos = 0, lvp = getLastValidPosition();\r\n                do {\r\n                    if (!0 === baseOnInput && getMaskSet().validPositions[pos]) testPos = clearOptionalTail && !0 === getMaskSet().validPositions[pos].match.optionality && getMaskSet().validPositions[pos + 1] === undefined && (!0 === getMaskSet().validPositions[pos].generatedInput || getMaskSet().validPositions[pos].input == opts.skipOptionalPartCharacter && pos > 0) ? determineTestTemplate(pos, getTests(pos, ndxIntlzr, pos - 1)) : getMaskSet().validPositions[pos], \r\n                    test = testPos.match, ndxIntlzr = testPos.locator.slice(), maskTemplate.push(!0 === includeMode ? testPos.input : !1 === includeMode ? test.nativeDef : getPlaceholder(pos, test)); else {\r\n                        testPos = getTestTemplate(pos, ndxIntlzr, pos - 1), test = testPos.match, ndxIntlzr = testPos.locator.slice();\r\n                        var jitMasking = !0 !== noJit && (!1 !== opts.jitMasking ? opts.jitMasking : test.jit);\r\n                        !1 === jitMasking || jitMasking === undefined || pos < lvp || \"number\" == typeof jitMasking && isFinite(jitMasking) && jitMasking > pos ? maskTemplate.push(!1 === includeMode ? test.nativeDef : getPlaceholder(pos, test)) : test.jit && test.optionalQuantifier;\r\n                    }\r\n                    \"auto\" === opts.keepStatic && test.newBlockMarker && null !== test.fn && (opts.keepStatic = pos - 1), \r\n                    pos++;\r\n                } while ((maxLength === undefined || pos < maxLength) && (null !== test.fn || \"\" !== test.def) || minimalPos > pos);\r\n                return \"\" === maskTemplate[maskTemplate.length - 1] && maskTemplate.pop(), !1 === includeMode && getMaskSet().maskLength !== undefined || (getMaskSet().maskLength = pos - 1), \r\n                opts.greedy = greedy, maskTemplate;\r\n            }\r\n            function getMaskSet() {\r\n                return maskset;\r\n            }\r\n            function resetMaskSet(soft) {\r\n                var maskset = getMaskSet();\r\n                maskset.buffer = undefined, !0 !== soft && (maskset.validPositions = {}, maskset.p = 0);\r\n            }\r\n            function getLastValidPosition(closestTo, strict, validPositions) {\r\n                var before = -1, after = -1, valids = validPositions || getMaskSet().validPositions;\r\n                for (var posNdx in closestTo === undefined && (closestTo = -1), valids) {\r\n                    var psNdx = parseInt(posNdx);\r\n                    valids[psNdx] && (strict || !0 !== valids[psNdx].generatedInput) && (psNdx <= closestTo && (before = psNdx), \r\n                    psNdx >= closestTo && (after = psNdx));\r\n                }\r\n                return -1 === before || before == closestTo ? after : -1 == after ? before : closestTo - before < after - closestTo ? before : after;\r\n            }\r\n            function getDecisionTaker(tst) {\r\n                var decisionTaker = tst.locator[tst.alternation];\r\n                return \"string\" == typeof decisionTaker && decisionTaker.length > 0 && (decisionTaker = decisionTaker.split(\",\")[0]), \r\n                decisionTaker !== undefined ? decisionTaker.toString() : \"\";\r\n            }\r\n            function getLocator(tst, align) {\r\n                var locator = (tst.alternation != undefined ? tst.mloc[getDecisionTaker(tst)] : tst.locator).join(\"\");\r\n                if (\"\" !== locator) for (;locator.length < align; ) locator += \"0\";\r\n                return locator;\r\n            }\r\n            function determineTestTemplate(pos, tests) {\r\n                for (var tstLocator, closest, bestMatch, altTest = getTest(pos = pos > 0 ? pos - 1 : 0), targetLocator = getLocator(altTest), ndx = 0; ndx < tests.length; ndx++) {\r\n                    var tst = tests[ndx];\r\n                    tstLocator = getLocator(tst, targetLocator.length);\r\n                    var distance = Math.abs(tstLocator - targetLocator);\r\n                    (closest === undefined || \"\" !== tstLocator && distance < closest || bestMatch && bestMatch.match.optionality && \"master\" === bestMatch.match.newBlockMarker && (!tst.match.optionality || !tst.match.newBlockMarker) || bestMatch && bestMatch.match.optionalQuantifier && !tst.match.optionalQuantifier) && (closest = distance, \r\n                    bestMatch = tst);\r\n                }\r\n                return bestMatch;\r\n            }\r\n            function getTestTemplate(pos, ndxIntlzr, tstPs) {\r\n                return getMaskSet().validPositions[pos] || determineTestTemplate(pos, getTests(pos, ndxIntlzr ? ndxIntlzr.slice() : ndxIntlzr, tstPs));\r\n            }\r\n            function getTest(pos, tests) {\r\n                return getMaskSet().validPositions[pos] ? getMaskSet().validPositions[pos] : (tests || getTests(pos))[0];\r\n            }\r\n            function positionCanMatchDefinition(pos, def) {\r\n                for (var valid = !1, tests = getTests(pos), tndx = 0; tndx < tests.length; tndx++) if (tests[tndx].match && tests[tndx].match.def === def) {\r\n                    valid = !0;\r\n                    break;\r\n                }\r\n                return valid;\r\n            }\r\n            function getTests(pos, ndxIntlzr, tstPs) {\r\n                var latestMatch, maskTokens = getMaskSet().maskToken, testPos = ndxIntlzr ? tstPs : 0, ndxInitializer = ndxIntlzr ? ndxIntlzr.slice() : [ 0 ], matches = [], insertStop = !1, cacheDependency = ndxIntlzr ? ndxIntlzr.join(\"\") : \"\";\r\n                function resolveTestFromToken(maskToken, ndxInitializer, loopNdx, quantifierRecurse) {\r\n                    function handleMatch(match, loopNdx, quantifierRecurse) {\r\n                        function isFirstMatch(latestMatch, tokenGroup) {\r\n                            var firstMatch = 0 === $.inArray(latestMatch, tokenGroup.matches);\r\n                            return firstMatch || $.each(tokenGroup.matches, function(ndx, match) {\r\n                                if (!0 === match.isQuantifier ? firstMatch = isFirstMatch(latestMatch, tokenGroup.matches[ndx - 1]) : !0 === match.isOptional ? firstMatch = isFirstMatch(latestMatch, match) : !0 === match.isAlternate && (firstMatch = isFirstMatch(latestMatch, match)), \r\n                                firstMatch) return !1;\r\n                            }), firstMatch;\r\n                        }\r\n                        function resolveNdxInitializer(pos, alternateNdx, targetAlternation) {\r\n                            var bestMatch, indexPos;\r\n                            if ((getMaskSet().tests[pos] || getMaskSet().validPositions[pos]) && $.each(getMaskSet().tests[pos] || [ getMaskSet().validPositions[pos] ], function(ndx, lmnt) {\r\n                                if (lmnt.mloc[alternateNdx]) return bestMatch = lmnt, !1;\r\n                                var alternation = targetAlternation !== undefined ? targetAlternation : lmnt.alternation, ndxPos = lmnt.locator[alternation] !== undefined ? lmnt.locator[alternation].toString().indexOf(alternateNdx) : -1;\r\n                                (indexPos === undefined || ndxPos < indexPos) && -1 !== ndxPos && (bestMatch = lmnt, \r\n                                indexPos = ndxPos);\r\n                            }), bestMatch) {\r\n                                var bestMatchAltIndex = bestMatch.locator[bestMatch.alternation], locator = bestMatch.mloc[alternateNdx] || bestMatch.mloc[bestMatchAltIndex] || bestMatch.locator;\r\n                                return locator.slice((targetAlternation !== undefined ? targetAlternation : bestMatch.alternation) + 1);\r\n                            }\r\n                            return targetAlternation !== undefined ? resolveNdxInitializer(pos, alternateNdx) : undefined;\r\n                        }\r\n                        function isSubsetOf(source, target) {\r\n                            function expand(pattern) {\r\n                                for (var start, end, expanded = [], i = 0, l = pattern.length; i < l; i++) if (\"-\" === pattern.charAt(i)) for (end = pattern.charCodeAt(i + 1); ++start < end; ) expanded.push(String.fromCharCode(start)); else start = pattern.charCodeAt(i), \r\n                                expanded.push(pattern.charAt(i));\r\n                                return expanded.join(\"\");\r\n                            }\r\n                            return opts.regex && null !== source.match.fn && null !== target.match.fn ? -1 !== expand(target.match.def.replace(/[\\[\\]]/g, \"\")).indexOf(expand(source.match.def.replace(/[\\[\\]]/g, \"\"))) : source.match.def === target.match.nativeDef;\r\n                        }\r\n                        function setMergeLocators(targetMatch, altMatch) {\r\n                            if (altMatch === undefined || targetMatch.alternation === altMatch.alternation && -1 === targetMatch.locator[targetMatch.alternation].toString().indexOf(altMatch.locator[altMatch.alternation])) {\r\n                                targetMatch.mloc = targetMatch.mloc || {};\r\n                                var locNdx = targetMatch.locator[targetMatch.alternation];\r\n                                if (locNdx !== undefined) {\r\n                                    if (\"string\" == typeof locNdx && (locNdx = locNdx.split(\",\")[0]), targetMatch.mloc[locNdx] === undefined && (targetMatch.mloc[locNdx] = targetMatch.locator.slice()), \r\n                                    altMatch !== undefined) {\r\n                                        for (var ndx in altMatch.mloc) \"string\" == typeof ndx && (ndx = ndx.split(\",\")[0]), \r\n                                        targetMatch.mloc[ndx] === undefined && (targetMatch.mloc[ndx] = altMatch.mloc[ndx]);\r\n                                        targetMatch.locator[targetMatch.alternation] = Object.keys(targetMatch.mloc).join(\",\");\r\n                                    }\r\n                                    return !0;\r\n                                }\r\n                                targetMatch.alternation = undefined;\r\n                            }\r\n                            return !1;\r\n                        }\r\n                        if (testPos > 5e3) throw \"Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. \" + getMaskSet().mask;\r\n                        if (testPos === pos && match.matches === undefined) return matches.push({\r\n                            match: match,\r\n                            locator: loopNdx.reverse(),\r\n                            cd: cacheDependency,\r\n                            mloc: {}\r\n                        }), !0;\r\n                        if (match.matches !== undefined) {\r\n                            if (match.isGroup && quantifierRecurse !== match) {\r\n                                if (match = handleMatch(maskToken.matches[$.inArray(match, maskToken.matches) + 1], loopNdx, quantifierRecurse)) return !0;\r\n                            } else if (match.isOptional) {\r\n                                var optionalToken = match;\r\n                                if (match = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse)) {\r\n                                    if ($.each(matches, function(ndx, mtch) {\r\n                                        mtch.match.optionality = !0;\r\n                                    }), latestMatch = matches[matches.length - 1].match, quantifierRecurse !== undefined || !isFirstMatch(latestMatch, optionalToken)) return !0;\r\n                                    insertStop = !0, testPos = pos;\r\n                                }\r\n                            } else if (match.isAlternator) {\r\n                                var maltMatches, alternateToken = match, malternateMatches = [], currentMatches = matches.slice(), loopNdxCnt = loopNdx.length, altIndex = ndxInitializer.length > 0 ? ndxInitializer.shift() : -1;\r\n                                if (-1 === altIndex || \"string\" == typeof altIndex) {\r\n                                    var amndx, currentPos = testPos, ndxInitializerClone = ndxInitializer.slice(), altIndexArr = [];\r\n                                    if (\"string\" == typeof altIndex) altIndexArr = altIndex.split(\",\"); else for (amndx = 0; amndx < alternateToken.matches.length; amndx++) altIndexArr.push(amndx.toString());\r\n                                    if (getMaskSet().excludes[pos]) {\r\n                                        for (var altIndexArrClone = altIndexArr.slice(), i = 0, el = getMaskSet().excludes[pos].length; i < el; i++) altIndexArr.splice(altIndexArr.indexOf(getMaskSet().excludes[pos][i].toString()), 1);\r\n                                        0 === altIndexArr.length && (getMaskSet().excludes[pos] = undefined, altIndexArr = altIndexArrClone);\r\n                                    }\r\n                                    (!0 === opts.keepStatic || isFinite(parseInt(opts.keepStatic)) && currentPos >= opts.keepStatic) && (altIndexArr = altIndexArr.slice(0, 1));\r\n                                    for (var unMatchedAlternation = !1, ndx = 0; ndx < altIndexArr.length; ndx++) {\r\n                                        amndx = parseInt(altIndexArr[ndx]), matches = [], ndxInitializer = \"string\" == typeof altIndex && resolveNdxInitializer(testPos, amndx, loopNdxCnt) || ndxInitializerClone.slice(), \r\n                                        alternateToken.matches[amndx] && handleMatch(alternateToken.matches[amndx], [ amndx ].concat(loopNdx), quantifierRecurse) ? match = !0 : 0 === ndx && (unMatchedAlternation = !0), \r\n                                        maltMatches = matches.slice(), testPos = currentPos, matches = [];\r\n                                        for (var ndx1 = 0; ndx1 < maltMatches.length; ndx1++) {\r\n                                            var altMatch = maltMatches[ndx1], dropMatch = !1;\r\n                                            altMatch.match.jit = altMatch.match.jit || unMatchedAlternation, altMatch.alternation = altMatch.alternation || loopNdxCnt, \r\n                                            setMergeLocators(altMatch);\r\n                                            for (var ndx2 = 0; ndx2 < malternateMatches.length; ndx2++) {\r\n                                                var altMatch2 = malternateMatches[ndx2];\r\n                                                if (\"string\" != typeof altIndex || altMatch.alternation !== undefined && -1 !== $.inArray(altMatch.locator[altMatch.alternation].toString(), altIndexArr)) {\r\n                                                    if (altMatch.match.nativeDef === altMatch2.match.nativeDef) {\r\n                                                        dropMatch = !0, setMergeLocators(altMatch2, altMatch);\r\n                                                        break;\r\n                                                    }\r\n                                                    if (isSubsetOf(altMatch, altMatch2)) {\r\n                                                        setMergeLocators(altMatch, altMatch2) && (dropMatch = !0, malternateMatches.splice(malternateMatches.indexOf(altMatch2), 0, altMatch));\r\n                                                        break;\r\n                                                    }\r\n                                                    if (isSubsetOf(altMatch2, altMatch)) {\r\n                                                        setMergeLocators(altMatch2, altMatch);\r\n                                                        break;\r\n                                                    }\r\n                                                    if (target = altMatch2, null === (source = altMatch).match.fn && null !== target.match.fn && target.match.fn.test(source.match.def, getMaskSet(), pos, !1, opts, !1)) {\r\n                                                        setMergeLocators(altMatch, altMatch2) && (dropMatch = !0, malternateMatches.splice(malternateMatches.indexOf(altMatch2), 0, altMatch));\r\n                                                        break;\r\n                                                    }\r\n                                                }\r\n                                            }\r\n                                            dropMatch || malternateMatches.push(altMatch);\r\n                                        }\r\n                                    }\r\n                                    matches = currentMatches.concat(malternateMatches), testPos = pos, insertStop = matches.length > 0, \r\n                                    match = malternateMatches.length > 0, ndxInitializer = ndxInitializerClone.slice();\r\n                                } else match = handleMatch(alternateToken.matches[altIndex] || maskToken.matches[altIndex], [ altIndex ].concat(loopNdx), quantifierRecurse);\r\n                                if (match) return !0;\r\n                            } else if (match.isQuantifier && quantifierRecurse !== maskToken.matches[$.inArray(match, maskToken.matches) - 1]) for (var qt = match, qndx = ndxInitializer.length > 0 ? ndxInitializer.shift() : 0; qndx < (isNaN(qt.quantifier.max) ? qndx + 1 : qt.quantifier.max) && testPos <= pos; qndx++) {\r\n                                var tokenGroup = maskToken.matches[$.inArray(qt, maskToken.matches) - 1];\r\n                                if (match = handleMatch(tokenGroup, [ qndx ].concat(loopNdx), tokenGroup)) {\r\n                                    if ((latestMatch = matches[matches.length - 1].match).optionalQuantifier = qndx > qt.quantifier.min - 1, \r\n                                    latestMatch.jit = qndx + tokenGroup.matches.indexOf(latestMatch) >= qt.quantifier.jit, \r\n                                    isFirstMatch(latestMatch, tokenGroup) && qndx > qt.quantifier.min - 1) {\r\n                                        insertStop = !0, testPos = pos;\r\n                                        break;\r\n                                    }\r\n                                    if (qt.quantifier.jit !== undefined && isNaN(qt.quantifier.max) && latestMatch.optionalQuantifier && getMaskSet().validPositions[pos - 1] === undefined) {\r\n                                        matches.pop(), insertStop = !0, testPos = pos, cacheDependency = undefined;\r\n                                        break;\r\n                                    }\r\n                                    return !0;\r\n                                }\r\n                            } else if (match = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse)) return !0;\r\n                        } else testPos++;\r\n                        var source, target;\r\n                    }\r\n                    for (var tndx = ndxInitializer.length > 0 ? ndxInitializer.shift() : 0; tndx < maskToken.matches.length; tndx++) if (!0 !== maskToken.matches[tndx].isQuantifier) {\r\n                        var match = handleMatch(maskToken.matches[tndx], [ tndx ].concat(loopNdx), quantifierRecurse);\r\n                        if (match && testPos === pos) return match;\r\n                        if (testPos > pos) break;\r\n                    }\r\n                }\r\n                if (pos > -1) {\r\n                    if (ndxIntlzr === undefined) {\r\n                        for (var test, previousPos = pos - 1; (test = getMaskSet().validPositions[previousPos] || getMaskSet().tests[previousPos]) === undefined && previousPos > -1; ) previousPos--;\r\n                        test !== undefined && previousPos > -1 && (ndxInitializer = function(pos, tests) {\r\n                            var locator = [];\r\n                            return $.isArray(tests) || (tests = [ tests ]), tests.length > 0 && (tests[0].alternation === undefined ? 0 === (locator = determineTestTemplate(pos, tests.slice()).locator.slice()).length && (locator = tests[0].locator.slice()) : $.each(tests, function(ndx, tst) {\r\n                                if (\"\" !== tst.def) if (0 === locator.length) locator = tst.locator.slice(); else for (var i = 0; i < locator.length; i++) tst.locator[i] && -1 === locator[i].toString().indexOf(tst.locator[i]) && (locator[i] += \",\" + tst.locator[i]);\r\n                            })), locator;\r\n                        }(previousPos, test), cacheDependency = ndxInitializer.join(\"\"), testPos = previousPos);\r\n                    }\r\n                    if (getMaskSet().tests[pos] && getMaskSet().tests[pos][0].cd === cacheDependency) return getMaskSet().tests[pos];\r\n                    for (var mtndx = ndxInitializer.shift(); mtndx < maskTokens.length; mtndx++) {\r\n                        var match = resolveTestFromToken(maskTokens[mtndx], ndxInitializer, [ mtndx ]);\r\n                        if (match && testPos === pos || testPos > pos) break;\r\n                    }\r\n                }\r\n                return (0 === matches.length || insertStop) && matches.push({\r\n                    match: {\r\n                        fn: null,\r\n                        optionality: !1,\r\n                        casing: null,\r\n                        def: \"\",\r\n                        placeholder: \"\"\r\n                    },\r\n                    locator: [],\r\n                    mloc: {},\r\n                    cd: cacheDependency\r\n                }), ndxIntlzr !== undefined && getMaskSet().tests[pos] ? $.extend(!0, [], matches) : (getMaskSet().tests[pos] = $.extend(!0, [], matches), \r\n                getMaskSet().tests[pos]);\r\n            }\r\n            function getBufferTemplate() {\r\n                return getMaskSet()._buffer === undefined && (getMaskSet()._buffer = getMaskTemplate(!1, 1), \r\n                getMaskSet().buffer === undefined && (getMaskSet().buffer = getMaskSet()._buffer.slice())), \r\n                getMaskSet()._buffer;\r\n            }\r\n            function getBuffer(noCache) {\r\n                return getMaskSet().buffer !== undefined && !0 !== noCache || (getMaskSet().buffer = getMaskTemplate(!0, getLastValidPosition(), !0)), \r\n                getMaskSet().buffer;\r\n            }\r\n            function refreshFromBuffer(start, end, buffer) {\r\n                var i, p;\r\n                if (!0 === start) resetMaskSet(), start = 0, end = buffer.length; else for (i = start; i < end; i++) delete getMaskSet().validPositions[i];\r\n                for (p = start, i = start; i < end; i++) if (resetMaskSet(!0), buffer[i] !== opts.skipOptionalPartCharacter) {\r\n                    var valResult = isValid(p, buffer[i], !0, !0);\r\n                    !1 !== valResult && (resetMaskSet(!0), p = valResult.caret !== undefined ? valResult.caret : valResult.pos + 1);\r\n                }\r\n            }\r\n            function checkAlternationMatch(altArr1, altArr2, na) {\r\n                for (var naNdx, altArrC = opts.greedy ? altArr2 : altArr2.slice(0, 1), isMatch = !1, naArr = na !== undefined ? na.split(\",\") : [], i = 0; i < naArr.length; i++) -1 !== (naNdx = altArr1.indexOf(naArr[i])) && altArr1.splice(naNdx, 1);\r\n                for (var alndx = 0; alndx < altArr1.length; alndx++) if (-1 !== $.inArray(altArr1[alndx], altArrC)) {\r\n                    isMatch = !0;\r\n                    break;\r\n                }\r\n                return isMatch;\r\n            }\r\n            function alternate(pos, c, strict, fromSetValid, rAltPos) {\r\n                var lastAlt, alternation, altPos, prevAltPos, i, validPos, decisionPos, validPsClone = $.extend(!0, {}, getMaskSet().validPositions), isValidRslt = !1, lAltPos = rAltPos !== undefined ? rAltPos : getLastValidPosition();\r\n                if (-1 === lAltPos && rAltPos === undefined) prevAltPos = getTest(lastAlt = 0), \r\n                alternation = prevAltPos.alternation; else for (;lAltPos >= 0; lAltPos--) if ((altPos = getMaskSet().validPositions[lAltPos]) && altPos.alternation !== undefined) {\r\n                    if (prevAltPos && prevAltPos.locator[altPos.alternation] !== altPos.locator[altPos.alternation]) break;\r\n                    lastAlt = lAltPos, alternation = getMaskSet().validPositions[lastAlt].alternation, \r\n                    prevAltPos = altPos;\r\n                }\r\n                if (alternation !== undefined) {\r\n                    decisionPos = parseInt(lastAlt), getMaskSet().excludes[decisionPos] = getMaskSet().excludes[decisionPos] || [], \r\n                    !0 !== pos && getMaskSet().excludes[decisionPos].push(getDecisionTaker(prevAltPos));\r\n                    var validInputsClone = [], staticInputsBeforePos = 0;\r\n                    for (i = decisionPos; i < getLastValidPosition(undefined, !0) + 1; i++) (validPos = getMaskSet().validPositions[i]) && !0 !== validPos.generatedInput ? validInputsClone.push(validPos.input) : i < pos && staticInputsBeforePos++, \r\n                    delete getMaskSet().validPositions[i];\r\n                    for (;getMaskSet().excludes[decisionPos] && getMaskSet().excludes[decisionPos].length < 10; ) {\r\n                        var posOffset = -1 * staticInputsBeforePos, validInputs = validInputsClone.slice();\r\n                        for (getMaskSet().tests[decisionPos] = undefined, resetMaskSet(!0), isValidRslt = !0; validInputs.length > 0; ) {\r\n                            var input = validInputs.shift();\r\n                            if (!(isValidRslt = isValid(getLastValidPosition(undefined, !0) + 1, input, !1, fromSetValid, !0))) break;\r\n                        }\r\n                        if (isValidRslt && c !== undefined) {\r\n                            var targetLvp = getLastValidPosition(pos) + 1;\r\n                            for (i = decisionPos; i < getLastValidPosition() + 1; i++) ((validPos = getMaskSet().validPositions[i]) === undefined || null == validPos.match.fn) && i < pos + posOffset && posOffset++;\r\n                            isValidRslt = isValid((pos += posOffset) > targetLvp ? targetLvp : pos, c, strict, fromSetValid, !0);\r\n                        }\r\n                        if (isValidRslt) break;\r\n                        if (resetMaskSet(), prevAltPos = getTest(decisionPos), getMaskSet().validPositions = $.extend(!0, {}, validPsClone), \r\n                        !getMaskSet().excludes[decisionPos]) {\r\n                            isValidRslt = alternate(pos, c, strict, fromSetValid, decisionPos - 1);\r\n                            break;\r\n                        }\r\n                        var decisionTaker = getDecisionTaker(prevAltPos);\r\n                        if (-1 !== getMaskSet().excludes[decisionPos].indexOf(decisionTaker)) {\r\n                            isValidRslt = alternate(pos, c, strict, fromSetValid, decisionPos - 1);\r\n                            break;\r\n                        }\r\n                        for (getMaskSet().excludes[decisionPos].push(decisionTaker), i = decisionPos; i < getLastValidPosition(undefined, !0) + 1; i++) delete getMaskSet().validPositions[i];\r\n                    }\r\n                }\r\n                return getMaskSet().excludes[decisionPos] = undefined, isValidRslt;\r\n            }\r\n            function isValid(pos, c, strict, fromSetValid, fromAlternate, validateOnly) {\r\n                function isSelection(posObj) {\r\n                    return isRTL ? posObj.begin - posObj.end > 1 || posObj.begin - posObj.end == 1 : posObj.end - posObj.begin > 1 || posObj.end - posObj.begin == 1;\r\n                }\r\n                strict = !0 === strict;\r\n                var maskPos = pos;\r\n                function _isValid(position, c, strict) {\r\n                    var rslt = !1;\r\n                    return $.each(getTests(position), function(ndx, tst) {\r\n                        var test = tst.match;\r\n                        if (getBuffer(!0), !1 !== (rslt = null != test.fn ? test.fn.test(c, getMaskSet(), position, strict, opts, isSelection(pos)) : (c === test.def || c === opts.skipOptionalPartCharacter) && \"\" !== test.def && {\r\n                            c: getPlaceholder(position, test, !0) || test.def,\r\n                            pos: position\r\n                        })) {\r\n                            var elem = rslt.c !== undefined ? rslt.c : c, validatedPos = position;\r\n                            return elem = elem === opts.skipOptionalPartCharacter && null === test.fn ? getPlaceholder(position, test, !0) || test.def : elem, \r\n                            rslt.remove !== undefined && ($.isArray(rslt.remove) || (rslt.remove = [ rslt.remove ]), \r\n                            $.each(rslt.remove.sort(function(a, b) {\r\n                                return b - a;\r\n                            }), function(ndx, lmnt) {\r\n                                revalidateMask({\r\n                                    begin: lmnt,\r\n                                    end: lmnt + 1\r\n                                });\r\n                            })), rslt.insert !== undefined && ($.isArray(rslt.insert) || (rslt.insert = [ rslt.insert ]), \r\n                            $.each(rslt.insert.sort(function(a, b) {\r\n                                return a - b;\r\n                            }), function(ndx, lmnt) {\r\n                                isValid(lmnt.pos, lmnt.c, !0, fromSetValid);\r\n                            })), !0 !== rslt && rslt.pos !== undefined && rslt.pos !== position && (validatedPos = rslt.pos), \r\n                            (!0 === rslt || rslt.pos !== undefined || rslt.c !== undefined) && (revalidateMask(pos, $.extend({}, tst, {\r\n                                input: function(elem, test, pos) {\r\n                                    switch (opts.casing || test.casing) {\r\n                                      case \"upper\":\r\n                                        elem = elem.toUpperCase();\r\n                                        break;\r\n\r\n                                      case \"lower\":\r\n                                        elem = elem.toLowerCase();\r\n                                        break;\r\n\r\n                                      case \"title\":\r\n                                        var posBefore = getMaskSet().validPositions[pos - 1];\r\n                                        elem = 0 === pos || posBefore && posBefore.input === String.fromCharCode(Inputmask.keyCode.SPACE) ? elem.toUpperCase() : elem.toLowerCase();\r\n                                        break;\r\n\r\n                                      default:\r\n                                        if ($.isFunction(opts.casing)) {\r\n                                            var args = Array.prototype.slice.call(arguments);\r\n                                            args.push(getMaskSet().validPositions), elem = opts.casing.apply(this, args);\r\n                                        }\r\n                                    }\r\n                                    return elem;\r\n                                }(elem, test, validatedPos)\r\n                            }), fromSetValid, validatedPos) || (rslt = !1), !1);\r\n                        }\r\n                    }), rslt;\r\n                }\r\n                pos.begin !== undefined && (maskPos = isRTL ? pos.end : pos.begin);\r\n                var result = !0, positionsClone = $.extend(!0, {}, getMaskSet().validPositions);\r\n                if ($.isFunction(opts.preValidation) && !strict && !0 !== fromSetValid && !0 !== validateOnly && (result = opts.preValidation(getBuffer(), maskPos, c, isSelection(pos), opts, getMaskSet())), \r\n                !0 === result) {\r\n                    if (trackbackPositions(undefined, maskPos, !0), (maxLength === undefined || maskPos < maxLength) && (result = _isValid(maskPos, c, strict), \r\n                    (!strict || !0 === fromSetValid) && !1 === result && !0 !== validateOnly)) {\r\n                        var currentPosValid = getMaskSet().validPositions[maskPos];\r\n                        if (!currentPosValid || null !== currentPosValid.match.fn || currentPosValid.match.def !== c && c !== opts.skipOptionalPartCharacter) {\r\n                            if ((opts.insertMode || getMaskSet().validPositions[seekNext(maskPos)] === undefined) && !isMask(maskPos, !0)) for (var nPos = maskPos + 1, snPos = seekNext(maskPos); nPos <= snPos; nPos++) if (!1 !== (result = _isValid(nPos, c, strict))) {\r\n                                result = trackbackPositions(maskPos, result.pos !== undefined ? result.pos : nPos) || result, \r\n                                maskPos = nPos;\r\n                                break;\r\n                            }\r\n                        } else result = {\r\n                            caret: seekNext(maskPos)\r\n                        };\r\n                    }\r\n                    !1 !== result || !1 === opts.keepStatic || null != opts.regex && !isComplete(getBuffer()) || strict || !0 === fromAlternate || (result = alternate(maskPos, c, strict, fromSetValid)), \r\n                    !0 === result && (result = {\r\n                        pos: maskPos\r\n                    });\r\n                }\r\n                if ($.isFunction(opts.postValidation) && !1 !== result && !strict && !0 !== fromSetValid && !0 !== validateOnly) {\r\n                    var postResult = opts.postValidation(getBuffer(!0), result, opts);\r\n                    if (postResult !== undefined) {\r\n                        if (postResult.refreshFromBuffer && postResult.buffer) {\r\n                            var refresh = postResult.refreshFromBuffer;\r\n                            refreshFromBuffer(!0 === refresh ? refresh : refresh.start, refresh.end, postResult.buffer);\r\n                        }\r\n                        result = !0 === postResult ? result : postResult;\r\n                    }\r\n                }\r\n                return result && result.pos === undefined && (result.pos = maskPos), !1 !== result && !0 !== validateOnly || (resetMaskSet(!0), \r\n                getMaskSet().validPositions = $.extend(!0, {}, positionsClone)), result;\r\n            }\r\n            function trackbackPositions(originalPos, newPos, fillOnly) {\r\n                var result;\r\n                if (originalPos === undefined) for (originalPos = newPos - 1; originalPos > 0 && !getMaskSet().validPositions[originalPos]; originalPos--) ;\r\n                for (var ps = originalPos; ps < newPos; ps++) if (getMaskSet().validPositions[ps] === undefined && !isMask(ps, !0)) {\r\n                    var vp = 0 == ps ? getTest(ps) : getMaskSet().validPositions[ps - 1];\r\n                    if (vp) {\r\n                        var tests = getTests(ps).slice();\r\n                        \"\" === tests[tests.length - 1].match.def && tests.pop();\r\n                        var bestMatch = determineTestTemplate(ps, tests);\r\n                        if ((bestMatch = $.extend({}, bestMatch, {\r\n                            input: getPlaceholder(ps, bestMatch.match, !0) || bestMatch.match.def\r\n                        })).generatedInput = !0, revalidateMask(ps, bestMatch, !0), !0 !== fillOnly) {\r\n                            var cvpInput = getMaskSet().validPositions[newPos].input;\r\n                            getMaskSet().validPositions[newPos] = undefined, result = isValid(newPos, cvpInput, !0, !0);\r\n                        }\r\n                    }\r\n                }\r\n                return result;\r\n            }\r\n            function revalidateMask(pos, validTest, fromSetValid, validatedPos) {\r\n                function IsEnclosedStatic(pos, valids, selection) {\r\n                    var posMatch = valids[pos];\r\n                    if (posMatch !== undefined && (null === posMatch.match.fn && !0 !== posMatch.match.optionality || posMatch.input === opts.radixPoint)) {\r\n                        var prevMatch = selection.begin <= pos - 1 ? valids[pos - 1] && null === valids[pos - 1].match.fn && valids[pos - 1] : valids[pos - 1], nextMatch = selection.end > pos + 1 ? valids[pos + 1] && null === valids[pos + 1].match.fn && valids[pos + 1] : valids[pos + 1];\r\n                        return prevMatch && nextMatch;\r\n                    }\r\n                    return !1;\r\n                }\r\n                var begin = pos.begin !== undefined ? pos.begin : pos, end = pos.end !== undefined ? pos.end : pos;\r\n                if (pos.begin > pos.end && (begin = pos.end, end = pos.begin), validatedPos = validatedPos !== undefined ? validatedPos : begin, \r\n                begin !== end || opts.insertMode && getMaskSet().validPositions[validatedPos] !== undefined && fromSetValid === undefined) {\r\n                    var positionsClone = $.extend(!0, {}, getMaskSet().validPositions), lvp = getLastValidPosition(undefined, !0);\r\n                    for (getMaskSet().p = begin, i = lvp; i >= begin; i--) getMaskSet().validPositions[i] && \"+\" === getMaskSet().validPositions[i].match.nativeDef && (opts.isNegative = !1), \r\n                    delete getMaskSet().validPositions[i];\r\n                    var valid = !0, j = validatedPos, needsValidation = (getMaskSet().validPositions, \r\n                    !1), posMatch = j, i = j;\r\n                    for (validTest && (getMaskSet().validPositions[validatedPos] = $.extend(!0, {}, validTest), \r\n                    posMatch++, j++, begin < end && i++); i <= lvp; i++) {\r\n                        var t = positionsClone[i];\r\n                        if (t !== undefined && (i >= end || i >= begin && !0 !== t.generatedInput && IsEnclosedStatic(i, positionsClone, {\r\n                            begin: begin,\r\n                            end: end\r\n                        }))) {\r\n                            for (;\"\" !== getTest(posMatch).match.def; ) {\r\n                                if (!1 === needsValidation && positionsClone[posMatch] && positionsClone[posMatch].match.nativeDef === t.match.nativeDef) getMaskSet().validPositions[posMatch] = $.extend(!0, {}, positionsClone[posMatch]), \r\n                                getMaskSet().validPositions[posMatch].input = t.input, trackbackPositions(undefined, posMatch, !0), \r\n                                j = posMatch + 1, valid = !0; else if (positionCanMatchDefinition(posMatch, t.match.def)) {\r\n                                    var result = isValid(posMatch, t.input, !0, !0);\r\n                                    valid = !1 !== result, j = result.caret || result.insert ? getLastValidPosition() : posMatch + 1, \r\n                                    needsValidation = !0;\r\n                                } else if (!(valid = !0 === t.generatedInput || t.input === opts.radixPoint && !0 === opts.numericInput) && \"\" === getTest(posMatch).match.def) break;\r\n                                if (valid) break;\r\n                                posMatch++;\r\n                            }\r\n                            \"\" == getTest(posMatch).match.def && (valid = !1), posMatch = j;\r\n                        }\r\n                        if (!valid) break;\r\n                    }\r\n                    if (!valid) return getMaskSet().validPositions = $.extend(!0, {}, positionsClone), \r\n                    resetMaskSet(!0), !1;\r\n                } else validTest && (getMaskSet().validPositions[validatedPos] = $.extend(!0, {}, validTest));\r\n                return resetMaskSet(!0), !0;\r\n            }\r\n            function isMask(pos, strict) {\r\n                var test = getTestTemplate(pos).match;\r\n                if (\"\" === test.def && (test = getTest(pos).match), null != test.fn) return test.fn;\r\n                if (!0 !== strict && pos > -1) {\r\n                    var tests = getTests(pos);\r\n                    return tests.length > 1 + (\"\" === tests[tests.length - 1].match.def ? 1 : 0);\r\n                }\r\n                return !1;\r\n            }\r\n            function seekNext(pos, newBlock) {\r\n                for (var position = pos + 1; \"\" !== getTest(position).match.def && (!0 === newBlock && (!0 !== getTest(position).match.newBlockMarker || !isMask(position)) || !0 !== newBlock && !isMask(position)); ) position++;\r\n                return position;\r\n            }\r\n            function seekPrevious(pos, newBlock) {\r\n                var tests, position = pos;\r\n                if (position <= 0) return 0;\r\n                for (;--position > 0 && (!0 === newBlock && !0 !== getTest(position).match.newBlockMarker || !0 !== newBlock && !isMask(position) && ((tests = getTests(position)).length < 2 || 2 === tests.length && \"\" === tests[1].match.def)); ) ;\r\n                return position;\r\n            }\r\n            function writeBuffer(input, buffer, caretPos, event, triggerEvents) {\r\n                if (event && $.isFunction(opts.onBeforeWrite)) {\r\n                    var result = opts.onBeforeWrite.call(inputmask, event, buffer, caretPos, opts);\r\n                    if (result) {\r\n                        if (result.refreshFromBuffer) {\r\n                            var refresh = result.refreshFromBuffer;\r\n                            refreshFromBuffer(!0 === refresh ? refresh : refresh.start, refresh.end, result.buffer || buffer), \r\n                            buffer = getBuffer(!0);\r\n                        }\r\n                        caretPos !== undefined && (caretPos = result.caret !== undefined ? result.caret : caretPos);\r\n                    }\r\n                }\r\n                if (input !== undefined && (input.inputmask._valueSet(buffer.join(\"\")), caretPos === undefined || event !== undefined && \"blur\" === event.type ? renderColorMask(input, caretPos, 0 === buffer.length) : caret(input, caretPos), \r\n                !0 === triggerEvents)) {\r\n                    var $input = $(input), nptVal = input.inputmask._valueGet();\r\n                    skipInputEvent = !0, $input.trigger(\"input\"), setTimeout(function() {\r\n                        nptVal === getBufferTemplate().join(\"\") ? $input.trigger(\"cleared\") : !0 === isComplete(buffer) && $input.trigger(\"complete\");\r\n                    }, 0);\r\n                }\r\n            }\r\n            function getPlaceholder(pos, test, returnPL) {\r\n                if ((test = test || getTest(pos).match).placeholder !== undefined || !0 === returnPL) return $.isFunction(test.placeholder) ? test.placeholder(opts) : test.placeholder;\r\n                if (null === test.fn) {\r\n                    if (pos > -1 && getMaskSet().validPositions[pos] === undefined) {\r\n                        var prevTest, tests = getTests(pos), staticAlternations = [];\r\n                        if (tests.length > 1 + (\"\" === tests[tests.length - 1].match.def ? 1 : 0)) for (var i = 0; i < tests.length; i++) if (!0 !== tests[i].match.optionality && !0 !== tests[i].match.optionalQuantifier && (null === tests[i].match.fn || prevTest === undefined || !1 !== tests[i].match.fn.test(prevTest.match.def, getMaskSet(), pos, !0, opts)) && (staticAlternations.push(tests[i]), \r\n                        null === tests[i].match.fn && (prevTest = tests[i]), staticAlternations.length > 1 && /[0-9a-bA-Z]/.test(staticAlternations[0].match.def))) return opts.placeholder.charAt(pos % opts.placeholder.length);\r\n                    }\r\n                    return test.def;\r\n                }\r\n                return opts.placeholder.charAt(pos % opts.placeholder.length);\r\n            }\r\n            var valueBuffer, EventRuler = {\r\n                on: function(input, eventName, eventHandler) {\r\n                    var ev = function(e) {\r\n                        var that = this;\r\n                        if (that.inputmask === undefined && \"FORM\" !== this.nodeName) {\r\n                            var imOpts = $.data(that, \"_inputmask_opts\");\r\n                            imOpts ? new Inputmask(imOpts).mask(that) : EventRuler.off(that);\r\n                        } else {\r\n                            if (\"setvalue\" === e.type || \"FORM\" === this.nodeName || !(that.disabled || that.readOnly && !(\"keydown\" === e.type && e.ctrlKey && 67 === e.keyCode || !1 === opts.tabThrough && e.keyCode === Inputmask.keyCode.TAB))) {\r\n                                switch (e.type) {\r\n                                  case \"input\":\r\n                                    if (!0 === skipInputEvent) return skipInputEvent = !1, e.preventDefault();\r\n                                    if (mobile) {\r\n                                        var args = arguments;\r\n                                        return setTimeout(function() {\r\n                                            eventHandler.apply(that, args), caret(that, that.inputmask.caretPos, undefined, !0);\r\n                                        }, 0), !1;\r\n                                    }\r\n                                    break;\r\n\r\n                                  case \"keydown\":\r\n                                    skipKeyPressEvent = !1, skipInputEvent = !1;\r\n                                    break;\r\n\r\n                                  case \"keypress\":\r\n                                    if (!0 === skipKeyPressEvent) return e.preventDefault();\r\n                                    skipKeyPressEvent = !0;\r\n                                    break;\r\n\r\n                                  case \"click\":\r\n                                    if (iemobile || iphone) {\r\n                                        var args = arguments;\r\n                                        return setTimeout(function() {\r\n                                            eventHandler.apply(that, args);\r\n                                        }, 0), !1;\r\n                                    }\r\n                                }\r\n                                var returnVal = eventHandler.apply(that, arguments);\r\n                                return !1 === returnVal && (e.preventDefault(), e.stopPropagation()), returnVal;\r\n                            }\r\n                            e.preventDefault();\r\n                        }\r\n                    };\r\n                    input.inputmask.events[eventName] = input.inputmask.events[eventName] || [], input.inputmask.events[eventName].push(ev), \r\n                    -1 !== $.inArray(eventName, [ \"submit\", \"reset\" ]) ? null !== input.form && $(input.form).on(eventName, ev) : $(input).on(eventName, ev);\r\n                },\r\n                off: function(input, event) {\r\n                    var events;\r\n                    input.inputmask && input.inputmask.events && (event ? (events = [])[event] = input.inputmask.events[event] : events = input.inputmask.events, \r\n                    $.each(events, function(eventName, evArr) {\r\n                        for (;evArr.length > 0; ) {\r\n                            var ev = evArr.pop();\r\n                            -1 !== $.inArray(eventName, [ \"submit\", \"reset\" ]) ? null !== input.form && $(input.form).off(eventName, ev) : $(input).off(eventName, ev);\r\n                        }\r\n                        delete input.inputmask.events[eventName];\r\n                    }));\r\n                }\r\n            }, EventHandlers = {\r\n                keydownEvent: function(e) {\r\n                    var $input = $(this), k = e.keyCode, pos = caret(this);\r\n                    if (k === Inputmask.keyCode.BACKSPACE || k === Inputmask.keyCode.DELETE || iphone && k === Inputmask.keyCode.BACKSPACE_SAFARI || e.ctrlKey && k === Inputmask.keyCode.X && !isInputEventSupported(\"cut\")) e.preventDefault(), \r\n                    handleRemove(0, k, pos), writeBuffer(this, getBuffer(!0), getMaskSet().p, e, this.inputmask._valueGet() !== getBuffer().join(\"\")); else if (k === Inputmask.keyCode.END || k === Inputmask.keyCode.PAGE_DOWN) {\r\n                        e.preventDefault();\r\n                        var caretPos = seekNext(getLastValidPosition());\r\n                        caret(this, e.shiftKey ? pos.begin : caretPos, caretPos, !0);\r\n                    } else k === Inputmask.keyCode.HOME && !e.shiftKey || k === Inputmask.keyCode.PAGE_UP ? (e.preventDefault(), \r\n                    caret(this, 0, e.shiftKey ? pos.begin : 0, !0)) : (opts.undoOnEscape && k === Inputmask.keyCode.ESCAPE || 90 === k && e.ctrlKey) && !0 !== e.altKey ? (checkVal(this, !0, !1, undoValue.split(\"\")), \r\n                    $input.trigger(\"click\")) : k !== Inputmask.keyCode.INSERT || e.shiftKey || e.ctrlKey ? !0 === opts.tabThrough && k === Inputmask.keyCode.TAB && (!0 === e.shiftKey ? (null === getTest(pos.begin).match.fn && (pos.begin = seekNext(pos.begin)), \r\n                    pos.end = seekPrevious(pos.begin, !0), pos.begin = seekPrevious(pos.end, !0)) : (pos.begin = seekNext(pos.begin, !0), \r\n                    pos.end = seekNext(pos.begin, !0), pos.end < getMaskSet().maskLength && pos.end--), \r\n                    pos.begin < getMaskSet().maskLength && (e.preventDefault(), caret(this, pos.begin, pos.end))) : (opts.insertMode = !opts.insertMode, \r\n                    this.setAttribute(\"im-insert\", opts.insertMode));\r\n                    opts.onKeyDown.call(this, e, getBuffer(), caret(this).begin, opts), ignorable = -1 !== $.inArray(k, opts.ignorables);\r\n                },\r\n                keypressEvent: function(e, checkval, writeOut, strict, ndx) {\r\n                    var input = this, $input = $(input), k = e.which || e.charCode || e.keyCode;\r\n                    if (!(!0 === checkval || e.ctrlKey && e.altKey) && (e.ctrlKey || e.metaKey || ignorable)) return k === Inputmask.keyCode.ENTER && undoValue !== getBuffer().join(\"\") && (undoValue = getBuffer().join(\"\"), \r\n                    setTimeout(function() {\r\n                        $input.trigger(\"change\");\r\n                    }, 0)), !0;\r\n                    if (k) {\r\n                        46 === k && !1 === e.shiftKey && \"\" !== opts.radixPoint && (k = opts.radixPoint.charCodeAt(0));\r\n                        var forwardPosition, pos = checkval ? {\r\n                            begin: ndx,\r\n                            end: ndx\r\n                        } : caret(input), c = String.fromCharCode(k), offset = 0;\r\n                        if (opts._radixDance && opts.numericInput) {\r\n                            var caretPos = getBuffer().indexOf(opts.radixPoint.charAt(0)) + 1;\r\n                            pos.begin <= caretPos && (k === opts.radixPoint.charCodeAt(0) && (offset = 1), pos.begin -= 1, \r\n                            pos.end -= 1);\r\n                        }\r\n                        getMaskSet().writeOutBuffer = !0;\r\n                        var valResult = isValid(pos, c, strict);\r\n                        if (!1 !== valResult && (resetMaskSet(!0), forwardPosition = valResult.caret !== undefined ? valResult.caret : seekNext(valResult.pos.begin ? valResult.pos.begin : valResult.pos), \r\n                        getMaskSet().p = forwardPosition), forwardPosition = (opts.numericInput && valResult.caret === undefined ? seekPrevious(forwardPosition) : forwardPosition) + offset, \r\n                        !1 !== writeOut && (setTimeout(function() {\r\n                            opts.onKeyValidation.call(input, k, valResult, opts);\r\n                        }, 0), getMaskSet().writeOutBuffer && !1 !== valResult)) {\r\n                            var buffer = getBuffer();\r\n                            writeBuffer(input, buffer, forwardPosition, e, !0 !== checkval);\r\n                        }\r\n                        if (e.preventDefault(), checkval) return !1 !== valResult && (valResult.forwardPosition = forwardPosition), \r\n                        valResult;\r\n                    }\r\n                },\r\n                pasteEvent: function(e) {\r\n                    var tempValue, ev = e.originalEvent || e, inputValue = ($(this), this.inputmask._valueGet(!0)), caretPos = caret(this);\r\n                    isRTL && (tempValue = caretPos.end, caretPos.end = caretPos.begin, caretPos.begin = tempValue);\r\n                    var valueBeforeCaret = inputValue.substr(0, caretPos.begin), valueAfterCaret = inputValue.substr(caretPos.end, inputValue.length);\r\n                    if (valueBeforeCaret === (isRTL ? getBufferTemplate().reverse() : getBufferTemplate()).slice(0, caretPos.begin).join(\"\") && (valueBeforeCaret = \"\"), \r\n                    valueAfterCaret === (isRTL ? getBufferTemplate().reverse() : getBufferTemplate()).slice(caretPos.end).join(\"\") && (valueAfterCaret = \"\"), \r\n                    window.clipboardData && window.clipboardData.getData) inputValue = valueBeforeCaret + window.clipboardData.getData(\"Text\") + valueAfterCaret; else {\r\n                        if (!ev.clipboardData || !ev.clipboardData.getData) return !0;\r\n                        inputValue = valueBeforeCaret + ev.clipboardData.getData(\"text/plain\") + valueAfterCaret;\r\n                    }\r\n                    var pasteValue = inputValue;\r\n                    if ($.isFunction(opts.onBeforePaste)) {\r\n                        if (!1 === (pasteValue = opts.onBeforePaste.call(inputmask, inputValue, opts))) return e.preventDefault();\r\n                        pasteValue || (pasteValue = inputValue);\r\n                    }\r\n                    return checkVal(this, !1, !1, pasteValue.toString().split(\"\")), writeBuffer(this, getBuffer(), seekNext(getLastValidPosition()), e, undoValue !== getBuffer().join(\"\")), \r\n                    e.preventDefault();\r\n                },\r\n                inputFallBackEvent: function(e) {\r\n                    var input = this, inputValue = input.inputmask._valueGet();\r\n                    if (getBuffer().join(\"\") !== inputValue) {\r\n                        var caretPos = caret(input);\r\n                        if (inputValue = function(input, inputValue, caretPos) {\r\n                            if (iemobile) {\r\n                                var inputChar = inputValue.replace(getBuffer().join(\"\"), \"\");\r\n                                if (1 === inputChar.length) {\r\n                                    var iv = inputValue.split(\"\");\r\n                                    iv.splice(caretPos.begin, 0, inputChar), inputValue = iv.join(\"\");\r\n                                }\r\n                            }\r\n                            return inputValue;\r\n                        }(0, inputValue = function(input, inputValue, caretPos) {\r\n                            return \".\" === inputValue.charAt(caretPos.begin - 1) && \"\" !== opts.radixPoint && ((inputValue = inputValue.split(\"\"))[caretPos.begin - 1] = opts.radixPoint.charAt(0), \r\n                            inputValue = inputValue.join(\"\")), inputValue;\r\n                        }(0, inputValue, caretPos), caretPos), getBuffer().join(\"\") !== inputValue) {\r\n                            var buffer = getBuffer().join(\"\"), offset = !opts.numericInput && inputValue.length > buffer.length ? -1 : 0, frontPart = inputValue.substr(0, caretPos.begin), backPart = inputValue.substr(caretPos.begin), frontBufferPart = buffer.substr(0, caretPos.begin + offset), backBufferPart = buffer.substr(caretPos.begin + offset), selection = caretPos, entries = \"\", isEntry = !1;\r\n                            if (frontPart !== frontBufferPart) {\r\n                                for (var fpl = (isEntry = frontPart.length >= frontBufferPart.length) ? frontPart.length : frontBufferPart.length, i = 0; frontPart.charAt(i) === frontBufferPart.charAt(i) && i < fpl; i++) ;\r\n                                isEntry && (0 === offset && (selection.begin = i), entries += frontPart.slice(i, selection.end));\r\n                            }\r\n                            if (backPart !== backBufferPart && (backPart.length > backBufferPart.length ? entries += backPart.slice(0, 1) : backPart.length < backBufferPart.length && (selection.end += backBufferPart.length - backPart.length, \r\n                            isEntry || \"\" === opts.radixPoint || \"\" !== backPart || frontPart.charAt(selection.begin + offset - 1) !== opts.radixPoint || (selection.begin--, \r\n                            entries = opts.radixPoint))), writeBuffer(input, getBuffer(), {\r\n                                begin: selection.begin + offset,\r\n                                end: selection.end + offset\r\n                            }), entries.length > 0) $.each(entries.split(\"\"), function(ndx, entry) {\r\n                                var keypress = new $.Event(\"keypress\");\r\n                                keypress.which = entry.charCodeAt(0), ignorable = !1, EventHandlers.keypressEvent.call(input, keypress);\r\n                            }); else {\r\n                                selection.begin === selection.end - 1 && (selection.begin = seekPrevious(selection.begin + 1), \r\n                                selection.begin === selection.end - 1 ? caret(input, selection.begin) : caret(input, selection.begin, selection.end));\r\n                                var keydown = new $.Event(\"keydown\");\r\n                                keydown.keyCode = opts.numericInput ? Inputmask.keyCode.BACKSPACE : Inputmask.keyCode.DELETE, \r\n                                EventHandlers.keydownEvent.call(input, keydown);\r\n                            }\r\n                            e.preventDefault();\r\n                        }\r\n                    }\r\n                },\r\n                beforeInputEvent: function(e) {\r\n                    if (e.cancelable) {\r\n                        var input = this;\r\n                        switch (e.inputType) {\r\n                          case \"insertText\":\r\n                            return $.each(e.data.split(\"\"), function(ndx, entry) {\r\n                                var keypress = new $.Event(\"keypress\");\r\n                                keypress.which = entry.charCodeAt(0), ignorable = !1, EventHandlers.keypressEvent.call(input, keypress);\r\n                            }), e.preventDefault();\r\n\r\n                          case \"deleteContentBackward\":\r\n                            var keydown = new $.Event(\"keydown\");\r\n                            return keydown.keyCode = Inputmask.keyCode.BACKSPACE, EventHandlers.keydownEvent.call(input, keydown), \r\n                            e.preventDefault();\r\n\r\n                          case \"deleteContentForward\":\r\n                            var keydown = new $.Event(\"keydown\");\r\n                            return keydown.keyCode = Inputmask.keyCode.DELETE, EventHandlers.keydownEvent.call(input, keydown), \r\n                            e.preventDefault();\r\n                        }\r\n                    }\r\n                },\r\n                setValueEvent: function(e) {\r\n                    this.inputmask.refreshValue = !1;\r\n                    var value = e && e.detail ? e.detail[0] : arguments[1], value = value || this.inputmask._valueGet(!0);\r\n                    $.isFunction(opts.onBeforeMask) && (value = opts.onBeforeMask.call(inputmask, value, opts) || value), \r\n                    checkVal(this, !0, !1, value = value.split(\"\")), undoValue = getBuffer().join(\"\"), \r\n                    (opts.clearMaskOnLostFocus || opts.clearIncomplete) && this.inputmask._valueGet() === getBufferTemplate().join(\"\") && this.inputmask._valueSet(\"\");\r\n                },\r\n                focusEvent: function(e) {\r\n                    var nptValue = this.inputmask._valueGet();\r\n                    opts.showMaskOnFocus && (!opts.showMaskOnHover || opts.showMaskOnHover && \"\" === nptValue) && (this.inputmask._valueGet() !== getBuffer().join(\"\") ? writeBuffer(this, getBuffer(), seekNext(getLastValidPosition())) : !1 === mouseEnter && caret(this, seekNext(getLastValidPosition()))), \r\n                    !0 === opts.positionCaretOnTab && !1 === mouseEnter && EventHandlers.clickEvent.apply(this, [ e, !0 ]), \r\n                    undoValue = getBuffer().join(\"\");\r\n                },\r\n                mouseleaveEvent: function(e) {\r\n                    mouseEnter = !1, opts.clearMaskOnLostFocus && document.activeElement !== this && (this.placeholder = \"\");\r\n                },\r\n                clickEvent: function(e, tabbed) {\r\n                    var input = this;\r\n                    setTimeout(function() {\r\n                        if (document.activeElement === input) {\r\n                            var selectedCaret = caret(input);\r\n                            if (tabbed && (isRTL ? selectedCaret.end = selectedCaret.begin : selectedCaret.begin = selectedCaret.end), \r\n                            selectedCaret.begin === selectedCaret.end) switch (opts.positionCaretOnClick) {\r\n                              case \"none\":\r\n                                break;\r\n\r\n                              case \"select\":\r\n                                caret(input, 0, getBuffer().length);\r\n                                break;\r\n\r\n                              case \"ignore\":\r\n                                caret(input, seekNext(getLastValidPosition()));\r\n                                break;\r\n\r\n                              case \"radixFocus\":\r\n                                if (function(clickPos) {\r\n                                    if (\"\" !== opts.radixPoint) {\r\n                                        var vps = getMaskSet().validPositions;\r\n                                        if (vps[clickPos] === undefined || vps[clickPos].input === getPlaceholder(clickPos)) {\r\n                                            if (clickPos < seekNext(-1)) return !0;\r\n                                            var radixPos = $.inArray(opts.radixPoint, getBuffer());\r\n                                            if (-1 !== radixPos) {\r\n                                                for (var vp in vps) if (radixPos < vp && vps[vp].input !== getPlaceholder(vp)) return !1;\r\n                                                return !0;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                    return !1;\r\n                                }(selectedCaret.begin)) {\r\n                                    var radixPos = getBuffer().join(\"\").indexOf(opts.radixPoint);\r\n                                    caret(input, opts.numericInput ? seekNext(radixPos) : radixPos);\r\n                                    break;\r\n                                }\r\n\r\n                              default:\r\n                                var clickPosition = selectedCaret.begin, lvclickPosition = getLastValidPosition(clickPosition, !0), lastPosition = seekNext(lvclickPosition);\r\n                                if (clickPosition < lastPosition) caret(input, isMask(clickPosition, !0) || isMask(clickPosition - 1, !0) ? clickPosition : seekNext(clickPosition)); else {\r\n                                    var lvp = getMaskSet().validPositions[lvclickPosition], tt = getTestTemplate(lastPosition, lvp ? lvp.match.locator : undefined, lvp), placeholder = getPlaceholder(lastPosition, tt.match);\r\n                                    if (\"\" !== placeholder && getBuffer()[lastPosition] !== placeholder && !0 !== tt.match.optionalQuantifier && !0 !== tt.match.newBlockMarker || !isMask(lastPosition, opts.keepStatic) && tt.match.def === placeholder) {\r\n                                        var newPos = seekNext(lastPosition);\r\n                                        (clickPosition >= newPos || clickPosition === lastPosition) && (lastPosition = newPos);\r\n                                    }\r\n                                    caret(input, lastPosition);\r\n                                }\r\n                            }\r\n                        }\r\n                    }, 0);\r\n                },\r\n                cutEvent: function(e) {\r\n                    $(this);\r\n                    var pos = caret(this), ev = e.originalEvent || e, clipboardData = window.clipboardData || ev.clipboardData, clipData = isRTL ? getBuffer().slice(pos.end, pos.begin) : getBuffer().slice(pos.begin, pos.end);\r\n                    clipboardData.setData(\"text\", isRTL ? clipData.reverse().join(\"\") : clipData.join(\"\")), \r\n                    document.execCommand && document.execCommand(\"copy\"), handleRemove(0, Inputmask.keyCode.DELETE, pos), \r\n                    writeBuffer(this, getBuffer(), getMaskSet().p, e, undoValue !== getBuffer().join(\"\"));\r\n                },\r\n                blurEvent: function(e) {\r\n                    var $input = $(this);\r\n                    if (this.inputmask) {\r\n                        this.placeholder = \"\";\r\n                        var nptValue = this.inputmask._valueGet(), buffer = getBuffer().slice();\r\n                        \"\" === nptValue && colorMask === undefined || (opts.clearMaskOnLostFocus && (-1 === getLastValidPosition() && nptValue === getBufferTemplate().join(\"\") ? buffer = [] : clearOptionalTail(buffer)), \r\n                        !1 === isComplete(buffer) && (setTimeout(function() {\r\n                            $input.trigger(\"incomplete\");\r\n                        }, 0), opts.clearIncomplete && (resetMaskSet(), buffer = opts.clearMaskOnLostFocus ? [] : getBufferTemplate().slice())), \r\n                        writeBuffer(this, buffer, undefined, e)), undoValue !== getBuffer().join(\"\") && (undoValue = buffer.join(\"\"), \r\n                        $input.trigger(\"change\"));\r\n                    }\r\n                },\r\n                mouseenterEvent: function(e) {\r\n                    mouseEnter = !0, document.activeElement !== this && opts.showMaskOnHover && (this.placeholder = getBuffer().join(\"\"));\r\n                },\r\n                submitEvent: function(e) {\r\n                    undoValue !== getBuffer().join(\"\") && $el.trigger(\"change\"), opts.clearMaskOnLostFocus && -1 === getLastValidPosition() && el.inputmask._valueGet && el.inputmask._valueGet() === getBufferTemplate().join(\"\") && el.inputmask._valueSet(\"\"), \r\n                    opts.clearIncomplete && !1 === isComplete(getBuffer()) && el.inputmask._valueSet(\"\"), \r\n                    opts.removeMaskOnSubmit && (el.inputmask._valueSet(el.inputmask.unmaskedvalue(), !0), \r\n                    setTimeout(function() {\r\n                        writeBuffer(el, getBuffer());\r\n                    }, 0));\r\n                },\r\n                resetEvent: function(e) {\r\n                    el.inputmask.refreshValue = !0, setTimeout(function() {\r\n                        $el.trigger(\"setvalue\");\r\n                    }, 0);\r\n                }\r\n            };\r\n            function checkVal(input, writeOut, strict, nptvl, initiatingEvent) {\r\n                var inputmask = this || input.inputmask, inputValue = nptvl.slice(), charCodes = \"\", initialNdx = -1, result = undefined;\r\n                if (resetMaskSet(), strict || !0 === opts.autoUnmask) initialNdx = seekNext(initialNdx); else {\r\n                    var staticInput = getBufferTemplate().slice(0, seekNext(-1)).join(\"\"), matches = inputValue.join(\"\").match(new RegExp(\"^\" + Inputmask.escapeRegex(staticInput), \"g\"));\r\n                    matches && matches.length > 0 && (inputValue.splice(0, matches.length * staticInput.length), \r\n                    initialNdx = seekNext(initialNdx));\r\n                }\r\n                -1 === initialNdx ? (getMaskSet().p = seekNext(initialNdx), initialNdx = 0) : getMaskSet().p = initialNdx, \r\n                inputmask.caretPos = {\r\n                    begin: initialNdx\r\n                }, $.each(inputValue, function(ndx, charCode) {\r\n                    if (charCode !== undefined) if (getMaskSet().validPositions[ndx] === undefined && inputValue[ndx] === getPlaceholder(ndx) && isMask(ndx, !0) && !1 === isValid(ndx, inputValue[ndx], !0, undefined, undefined, !0)) getMaskSet().p++; else {\r\n                        var keypress = new $.Event(\"_checkval\");\r\n                        keypress.which = charCode.charCodeAt(0), charCodes += charCode;\r\n                        var lvp = getLastValidPosition(undefined, !0);\r\n                        !function(ndx, charCodes) {\r\n                            return -1 !== getMaskTemplate(!0, 0, !1).slice(ndx, seekNext(ndx)).join(\"\").replace(/'/g, \"\").indexOf(charCodes) && !isMask(ndx) && (getTest(ndx).match.nativeDef === charCodes.charAt(0) || null === getTest(ndx).match.fn && getTest(ndx).match.nativeDef === \"'\" + charCodes.charAt(0) || \" \" === getTest(ndx).match.nativeDef && (getTest(ndx + 1).match.nativeDef === charCodes.charAt(0) || null === getTest(ndx + 1).match.fn && getTest(ndx + 1).match.nativeDef === \"'\" + charCodes.charAt(0)));\r\n                        }(initialNdx, charCodes) ? (result = EventHandlers.keypressEvent.call(input, keypress, !0, !1, strict, inputmask.caretPos.begin)) && (initialNdx = inputmask.caretPos.begin + 1, \r\n                        charCodes = \"\") : result = EventHandlers.keypressEvent.call(input, keypress, !0, !1, strict, lvp + 1), \r\n                        result && (writeBuffer(undefined, getBuffer(), result.forwardPosition, keypress, !1), \r\n                        inputmask.caretPos = {\r\n                            begin: result.forwardPosition,\r\n                            end: result.forwardPosition\r\n                        });\r\n                    }\r\n                }), writeOut && writeBuffer(input, getBuffer(), result ? result.forwardPosition : undefined, initiatingEvent || new $.Event(\"checkval\"), initiatingEvent && \"input\" === initiatingEvent.type);\r\n            }\r\n            function unmaskedvalue(input) {\r\n                if (input) {\r\n                    if (input.inputmask === undefined) return input.value;\r\n                    input.inputmask && input.inputmask.refreshValue && EventHandlers.setValueEvent.call(input);\r\n                }\r\n                var umValue = [], vps = getMaskSet().validPositions;\r\n                for (var pndx in vps) vps[pndx].match && null != vps[pndx].match.fn && umValue.push(vps[pndx].input);\r\n                var unmaskedValue = 0 === umValue.length ? \"\" : (isRTL ? umValue.reverse() : umValue).join(\"\");\r\n                if ($.isFunction(opts.onUnMask)) {\r\n                    var bufferValue = (isRTL ? getBuffer().slice().reverse() : getBuffer()).join(\"\");\r\n                    unmaskedValue = opts.onUnMask.call(inputmask, bufferValue, unmaskedValue, opts);\r\n                }\r\n                return unmaskedValue;\r\n            }\r\n            function translatePosition(pos) {\r\n                return !isRTL || \"number\" != typeof pos || opts.greedy && \"\" === opts.placeholder || !el || (pos = el.inputmask._valueGet().length - pos), \r\n                pos;\r\n            }\r\n            function caret(input, begin, end, notranslate) {\r\n                var range;\r\n                if (begin === undefined) return \"selectionStart\" in input ? (begin = input.selectionStart, \r\n                end = input.selectionEnd) : window.getSelection ? (range = window.getSelection().getRangeAt(0)).commonAncestorContainer.parentNode !== input && range.commonAncestorContainer !== input || (begin = range.startOffset, \r\n                end = range.endOffset) : document.selection && document.selection.createRange && (range = document.selection.createRange(), \r\n                begin = 0 - range.duplicate().moveStart(\"character\", -input.inputmask._valueGet().length), \r\n                end = begin + range.text.length), {\r\n                    begin: notranslate ? begin : translatePosition(begin),\r\n                    end: notranslate ? end : translatePosition(end)\r\n                };\r\n                if ($.isArray(begin) && (end = isRTL ? begin[0] : begin[1], begin = isRTL ? begin[1] : begin[0]), \r\n                begin.begin !== undefined && (end = isRTL ? begin.begin : begin.end, begin = isRTL ? begin.end : begin.begin), \r\n                \"number\" == typeof begin) {\r\n                    begin = notranslate ? begin : translatePosition(begin), end = \"number\" == typeof (end = notranslate ? end : translatePosition(end)) ? end : begin;\r\n                    var scrollCalc = parseInt(((input.ownerDocument.defaultView || window).getComputedStyle ? (input.ownerDocument.defaultView || window).getComputedStyle(input, null) : input.currentStyle).fontSize) * end;\r\n                    if (input.scrollLeft = scrollCalc > input.scrollWidth ? scrollCalc : 0, input.inputmask.caretPos = {\r\n                        begin: begin,\r\n                        end: end\r\n                    }, \"selectionStart\" in input) input.selectionStart = begin, input.selectionEnd = end; else if (window.getSelection) {\r\n                        if (range = document.createRange(), input.firstChild === undefined || null === input.firstChild) {\r\n                            var textNode = document.createTextNode(\"\");\r\n                            input.appendChild(textNode);\r\n                        }\r\n                        range.setStart(input.firstChild, begin < input.inputmask._valueGet().length ? begin : input.inputmask._valueGet().length), \r\n                        range.setEnd(input.firstChild, end < input.inputmask._valueGet().length ? end : input.inputmask._valueGet().length), \r\n                        range.collapse(!0);\r\n                        var sel = window.getSelection();\r\n                        sel.removeAllRanges(), sel.addRange(range);\r\n                    } else input.createTextRange && ((range = input.createTextRange()).collapse(!0), \r\n                    range.moveEnd(\"character\", end), range.moveStart(\"character\", begin), range.select());\r\n                    renderColorMask(input, {\r\n                        begin: begin,\r\n                        end: end\r\n                    });\r\n                }\r\n            }\r\n            function determineLastRequiredPosition(returnDefinition) {\r\n                var pos, testPos, buffer = getMaskTemplate(!0, getLastValidPosition(), !0, !0), bl = buffer.length, lvp = getLastValidPosition(), positions = {}, lvTest = getMaskSet().validPositions[lvp], ndxIntlzr = lvTest !== undefined ? lvTest.locator.slice() : undefined;\r\n                for (pos = lvp + 1; pos < buffer.length; pos++) testPos = getTestTemplate(pos, ndxIntlzr, pos - 1), \r\n                ndxIntlzr = testPos.locator.slice(), positions[pos] = $.extend(!0, {}, testPos);\r\n                var lvTestAlt = lvTest && lvTest.alternation !== undefined ? lvTest.locator[lvTest.alternation] : undefined;\r\n                for (pos = bl - 1; pos > lvp && ((testPos = positions[pos]).match.optionality || testPos.match.optionalQuantifier && testPos.match.newBlockMarker || lvTestAlt && (lvTestAlt !== positions[pos].locator[lvTest.alternation] && null != testPos.match.fn || null === testPos.match.fn && testPos.locator[lvTest.alternation] && checkAlternationMatch(testPos.locator[lvTest.alternation].toString().split(\",\"), lvTestAlt.toString().split(\",\")) && \"\" !== getTests(pos)[0].def)) && buffer[pos] === getPlaceholder(pos, testPos.match); pos--) bl--;\r\n                return returnDefinition ? {\r\n                    l: bl,\r\n                    def: positions[bl] ? positions[bl].match : undefined\r\n                } : bl;\r\n            }\r\n            function clearOptionalTail(buffer) {\r\n                buffer.length = 0;\r\n                for (var lmnt, template = getMaskTemplate(!0, 0, !0, undefined, !0); (lmnt = template.shift()) !== undefined; ) buffer.push(lmnt);\r\n                return buffer;\r\n            }\r\n            function isComplete(buffer) {\r\n                if ($.isFunction(opts.isComplete)) return opts.isComplete(buffer, opts);\r\n                if (\"*\" === opts.repeat) return undefined;\r\n                var complete = !1, lrp = determineLastRequiredPosition(!0), aml = seekPrevious(lrp.l);\r\n                if (lrp.def === undefined || lrp.def.newBlockMarker || lrp.def.optionality || lrp.def.optionalQuantifier) {\r\n                    complete = !0;\r\n                    for (var i = 0; i <= aml; i++) {\r\n                        var test = getTestTemplate(i).match;\r\n                        if (null !== test.fn && getMaskSet().validPositions[i] === undefined && !0 !== test.optionality && !0 !== test.optionalQuantifier || null === test.fn && buffer[i] !== getPlaceholder(i, test)) {\r\n                            complete = !1;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                return complete;\r\n            }\r\n            function handleRemove(input, k, pos, strict, fromIsValid) {\r\n                if ((opts.numericInput || isRTL) && (k === Inputmask.keyCode.BACKSPACE ? k = Inputmask.keyCode.DELETE : k === Inputmask.keyCode.DELETE && (k = Inputmask.keyCode.BACKSPACE), \r\n                isRTL)) {\r\n                    var pend = pos.end;\r\n                    pos.end = pos.begin, pos.begin = pend;\r\n                }\r\n                if (k === Inputmask.keyCode.BACKSPACE && pos.end - pos.begin < 1 ? (pos.begin = seekPrevious(pos.begin), \r\n                getMaskSet().validPositions[pos.begin] !== undefined && getMaskSet().validPositions[pos.begin].input === opts.groupSeparator && pos.begin--) : k === Inputmask.keyCode.DELETE && pos.begin === pos.end && (pos.end = isMask(pos.end, !0) && getMaskSet().validPositions[pos.end] && getMaskSet().validPositions[pos.end].input !== opts.radixPoint ? pos.end + 1 : seekNext(pos.end) + 1, \r\n                getMaskSet().validPositions[pos.begin] !== undefined && getMaskSet().validPositions[pos.begin].input === opts.groupSeparator && pos.end++), \r\n                revalidateMask(pos), !0 !== strict && !1 !== opts.keepStatic || null !== opts.regex) {\r\n                    var result = alternate(!0);\r\n                    if (result) {\r\n                        var newPos = result.caret !== undefined ? result.caret : result.pos ? seekNext(result.pos.begin ? result.pos.begin : result.pos) : getLastValidPosition(-1, !0);\r\n                        (k !== Inputmask.keyCode.DELETE || pos.begin > newPos) && pos.begin;\r\n                    }\r\n                }\r\n                var lvp = getLastValidPosition(pos.begin, !0);\r\n                if (lvp < pos.begin || -1 === pos.begin) getMaskSet().p = seekNext(lvp); else if (!0 !== strict && (getMaskSet().p = pos.begin, \r\n                !0 !== fromIsValid)) for (;getMaskSet().p < lvp && getMaskSet().validPositions[getMaskSet().p] === undefined; ) getMaskSet().p++;\r\n            }\r\n            function initializeColorMask(input) {\r\n                var computedStyle = (input.ownerDocument.defaultView || window).getComputedStyle(input, null), template = document.createElement(\"div\");\r\n                template.style.width = computedStyle.width, template.style.textAlign = computedStyle.textAlign, \r\n                colorMask = document.createElement(\"div\"), input.inputmask.colorMask = colorMask, \r\n                colorMask.className = \"im-colormask\", input.parentNode.insertBefore(colorMask, input), \r\n                input.parentNode.removeChild(input), colorMask.appendChild(input), colorMask.appendChild(template), \r\n                input.style.left = template.offsetLeft + \"px\", $(colorMask).on(\"mouseleave\", function(e) {\r\n                    return EventHandlers.mouseleaveEvent.call(input, [ e ]);\r\n                }), $(colorMask).on(\"mouseenter\", function(e) {\r\n                    return EventHandlers.mouseenterEvent.call(input, [ e ]);\r\n                }), $(colorMask).on(\"click\", function(e) {\r\n                    return caret(input, function(clientx) {\r\n                        var caretPos, e = document.createElement(\"span\");\r\n                        for (var style in computedStyle) isNaN(style) && -1 !== style.indexOf(\"font\") && (e.style[style] = computedStyle[style]);\r\n                        e.style.textTransform = computedStyle.textTransform, e.style.letterSpacing = computedStyle.letterSpacing, \r\n                        e.style.position = \"absolute\", e.style.height = \"auto\", e.style.width = \"auto\", \r\n                        e.style.visibility = \"hidden\", e.style.whiteSpace = \"nowrap\", document.body.appendChild(e);\r\n                        var itl, inputText = input.inputmask._valueGet(), previousWidth = 0;\r\n                        for (caretPos = 0, itl = inputText.length; caretPos <= itl; caretPos++) {\r\n                            if (e.innerHTML += inputText.charAt(caretPos) || \"_\", e.offsetWidth >= clientx) {\r\n                                var offset1 = clientx - previousWidth, offset2 = e.offsetWidth - clientx;\r\n                                e.innerHTML = inputText.charAt(caretPos), offset1 -= e.offsetWidth / 3, caretPos = offset1 < offset2 ? caretPos - 1 : caretPos;\r\n                                break;\r\n                            }\r\n                            previousWidth = e.offsetWidth;\r\n                        }\r\n                        return document.body.removeChild(e), caretPos;\r\n                    }(e.clientX)), EventHandlers.clickEvent.call(input, [ e ]);\r\n                });\r\n            }\r\n            function renderColorMask(input, caretPos, clear) {\r\n                var test, testPos, ndxIntlzr, maskTemplate = [], isStatic = !1, pos = 0;\r\n                function setEntry(entry) {\r\n                    if (entry === undefined && (entry = \"\"), isStatic || null !== test.fn && testPos.input !== undefined) if (isStatic && (null !== test.fn && testPos.input !== undefined || \"\" === test.def)) {\r\n                        isStatic = !1;\r\n                        var mtl = maskTemplate.length;\r\n                        maskTemplate[mtl - 1] = maskTemplate[mtl - 1] + \"</span>\", maskTemplate.push(entry);\r\n                    } else maskTemplate.push(entry); else isStatic = !0, maskTemplate.push(\"<span class='im-static'>\" + entry);\r\n                }\r\n                if (colorMask !== undefined) {\r\n                    var buffer = getBuffer();\r\n                    if (caretPos === undefined ? caretPos = caret(input) : caretPos.begin === undefined && (caretPos = {\r\n                        begin: caretPos,\r\n                        end: caretPos\r\n                    }), !0 !== clear) {\r\n                        var lvp = getLastValidPosition();\r\n                        do {\r\n                            getMaskSet().validPositions[pos] ? (testPos = getMaskSet().validPositions[pos], \r\n                            test = testPos.match, ndxIntlzr = testPos.locator.slice(), setEntry(buffer[pos])) : (testPos = getTestTemplate(pos, ndxIntlzr, pos - 1), \r\n                            test = testPos.match, ndxIntlzr = testPos.locator.slice(), !1 === opts.jitMasking || pos < lvp || \"number\" == typeof opts.jitMasking && isFinite(opts.jitMasking) && opts.jitMasking > pos ? setEntry(getPlaceholder(pos, test)) : isStatic = !1), \r\n                            pos++;\r\n                        } while ((maxLength === undefined || pos < maxLength) && (null !== test.fn || \"\" !== test.def) || lvp > pos || isStatic);\r\n                        isStatic && setEntry(), document.activeElement === input && (maskTemplate.splice(caretPos.begin, 0, caretPos.begin === caretPos.end || caretPos.end > getMaskSet().maskLength ? '<mark class=\"im-caret\" style=\"border-right-width: 1px;border-right-style: solid;\">' : '<mark class=\"im-caret-select\">'), \r\n                        maskTemplate.splice(caretPos.end + 1, 0, \"</mark>\"));\r\n                    }\r\n                    var template = colorMask.getElementsByTagName(\"div\")[0];\r\n                    template.innerHTML = maskTemplate.join(\"\"), input.inputmask.positionColorMask(input, template);\r\n                }\r\n            }\r\n            if (Inputmask.prototype.positionColorMask = function(input, template) {\r\n                input.style.left = template.offsetLeft + \"px\";\r\n            }, actionObj !== undefined) switch (actionObj.action) {\r\n              case \"isComplete\":\r\n                return el = actionObj.el, isComplete(getBuffer());\r\n\r\n              case \"unmaskedvalue\":\r\n                return el !== undefined && actionObj.value === undefined || (valueBuffer = actionObj.value, \r\n                valueBuffer = ($.isFunction(opts.onBeforeMask) && opts.onBeforeMask.call(inputmask, valueBuffer, opts) || valueBuffer).split(\"\"), \r\n                checkVal.call(this, undefined, !1, !1, valueBuffer), $.isFunction(opts.onBeforeWrite) && opts.onBeforeWrite.call(inputmask, undefined, getBuffer(), 0, opts)), \r\n                unmaskedvalue(el);\r\n\r\n              case \"mask\":\r\n                !function(elem) {\r\n                    EventRuler.off(elem);\r\n                    var isSupported = function(input, opts) {\r\n                        var elementType = input.getAttribute(\"type\"), isSupported = \"INPUT\" === input.tagName && -1 !== $.inArray(elementType, opts.supportsInputType) || input.isContentEditable || \"TEXTAREA\" === input.tagName;\r\n                        if (!isSupported) if (\"INPUT\" === input.tagName) {\r\n                            var el = document.createElement(\"input\");\r\n                            el.setAttribute(\"type\", elementType), isSupported = \"text\" === el.type, el = null;\r\n                        } else isSupported = \"partial\";\r\n                        return !1 !== isSupported ? function(npt) {\r\n                            var valueGet, valueSet;\r\n                            function getter() {\r\n                                return this.inputmask ? this.inputmask.opts.autoUnmask ? this.inputmask.unmaskedvalue() : -1 !== getLastValidPosition() || !0 !== opts.nullable ? document.activeElement === this && opts.clearMaskOnLostFocus ? (isRTL ? clearOptionalTail(getBuffer().slice()).reverse() : clearOptionalTail(getBuffer().slice())).join(\"\") : valueGet.call(this) : \"\" : valueGet.call(this);\r\n                            }\r\n                            function setter(value) {\r\n                                valueSet.call(this, value), this.inputmask && $(this).trigger(\"setvalue\", [ value ]);\r\n                            }\r\n                            if (!npt.inputmask.__valueGet) {\r\n                                if (!0 !== opts.noValuePatching) {\r\n                                    if (Object.getOwnPropertyDescriptor) {\r\n                                        \"function\" != typeof Object.getPrototypeOf && (Object.getPrototypeOf = \"object\" === _typeof(\"test\".__proto__) ? function(object) {\r\n                                            return object.__proto__;\r\n                                        } : function(object) {\r\n                                            return object.constructor.prototype;\r\n                                        });\r\n                                        var valueProperty = Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(npt), \"value\") : undefined;\r\n                                        valueProperty && valueProperty.get && valueProperty.set ? (valueGet = valueProperty.get, \r\n                                        valueSet = valueProperty.set, Object.defineProperty(npt, \"value\", {\r\n                                            get: getter,\r\n                                            set: setter,\r\n                                            configurable: !0\r\n                                        })) : \"INPUT\" !== npt.tagName && (valueGet = function() {\r\n                                            return this.textContent;\r\n                                        }, valueSet = function(value) {\r\n                                            this.textContent = value;\r\n                                        }, Object.defineProperty(npt, \"value\", {\r\n                                            get: getter,\r\n                                            set: setter,\r\n                                            configurable: !0\r\n                                        }));\r\n                                    } else document.__lookupGetter__ && npt.__lookupGetter__(\"value\") && (valueGet = npt.__lookupGetter__(\"value\"), \r\n                                    valueSet = npt.__lookupSetter__(\"value\"), npt.__defineGetter__(\"value\", getter), \r\n                                    npt.__defineSetter__(\"value\", setter));\r\n                                    npt.inputmask.__valueGet = valueGet, npt.inputmask.__valueSet = valueSet;\r\n                                }\r\n                                npt.inputmask._valueGet = function(overruleRTL) {\r\n                                    return isRTL && !0 !== overruleRTL ? valueGet.call(this.el).split(\"\").reverse().join(\"\") : valueGet.call(this.el);\r\n                                }, npt.inputmask._valueSet = function(value, overruleRTL) {\r\n                                    valueSet.call(this.el, null === value || value === undefined ? \"\" : !0 !== overruleRTL && isRTL ? value.split(\"\").reverse().join(\"\") : value);\r\n                                }, valueGet === undefined && (valueGet = function() {\r\n                                    return this.value;\r\n                                }, valueSet = function(value) {\r\n                                    this.value = value;\r\n                                }, function(type) {\r\n                                    if ($.valHooks && ($.valHooks[type] === undefined || !0 !== $.valHooks[type].inputmaskpatch)) {\r\n                                        var valhookGet = $.valHooks[type] && $.valHooks[type].get ? $.valHooks[type].get : function(elem) {\r\n                                            return elem.value;\r\n                                        }, valhookSet = $.valHooks[type] && $.valHooks[type].set ? $.valHooks[type].set : function(elem, value) {\r\n                                            return elem.value = value, elem;\r\n                                        };\r\n                                        $.valHooks[type] = {\r\n                                            get: function(elem) {\r\n                                                if (elem.inputmask) {\r\n                                                    if (elem.inputmask.opts.autoUnmask) return elem.inputmask.unmaskedvalue();\r\n                                                    var result = valhookGet(elem);\r\n                                                    return -1 !== getLastValidPosition(undefined, undefined, elem.inputmask.maskset.validPositions) || !0 !== opts.nullable ? result : \"\";\r\n                                                }\r\n                                                return valhookGet(elem);\r\n                                            },\r\n                                            set: function(elem, value) {\r\n                                                var result, $elem = $(elem);\r\n                                                return result = valhookSet(elem, value), elem.inputmask && $elem.trigger(\"setvalue\", [ value ]), \r\n                                                result;\r\n                                            },\r\n                                            inputmaskpatch: !0\r\n                                        };\r\n                                    }\r\n                                }(npt.type), function(npt) {\r\n                                    EventRuler.on(npt, \"mouseenter\", function(event) {\r\n                                        var $input = $(this), value = this.inputmask._valueGet();\r\n                                        value !== getBuffer().join(\"\") && $input.trigger(\"setvalue\");\r\n                                    });\r\n                                }(npt));\r\n                            }\r\n                        }(input) : input.inputmask = undefined, isSupported;\r\n                    }(elem, opts);\r\n                    if (!1 !== isSupported && ($el = $(el = elem), -1 === (maxLength = el !== undefined ? el.maxLength : undefined) && (maxLength = undefined), \r\n                    !0 === opts.colorMask && initializeColorMask(el), mobile && (\"inputmode\" in el && (el.inputmode = opts.inputmode, \r\n                    el.setAttribute(\"inputmode\", opts.inputmode)), !0 === opts.disablePredictiveText && (\"autocorrect\" in el ? el.autocorrect = !1 : (!0 !== opts.colorMask && initializeColorMask(el), \r\n                    el.type = \"password\"))), !0 === isSupported && (el.setAttribute(\"im-insert\", opts.insertMode), \r\n                    EventRuler.on(el, \"submit\", EventHandlers.submitEvent), EventRuler.on(el, \"reset\", EventHandlers.resetEvent), \r\n                    EventRuler.on(el, \"blur\", EventHandlers.blurEvent), EventRuler.on(el, \"focus\", EventHandlers.focusEvent), \r\n                    !0 !== opts.colorMask && (EventRuler.on(el, \"click\", EventHandlers.clickEvent), \r\n                    EventRuler.on(el, \"mouseleave\", EventHandlers.mouseleaveEvent), EventRuler.on(el, \"mouseenter\", EventHandlers.mouseenterEvent)), \r\n                    EventRuler.on(el, \"paste\", EventHandlers.pasteEvent), EventRuler.on(el, \"cut\", EventHandlers.cutEvent), \r\n                    EventRuler.on(el, \"complete\", opts.oncomplete), EventRuler.on(el, \"incomplete\", opts.onincomplete), \r\n                    EventRuler.on(el, \"cleared\", opts.oncleared), mobile || !0 === opts.inputEventOnly ? el.removeAttribute(\"maxLength\") : (EventRuler.on(el, \"keydown\", EventHandlers.keydownEvent), \r\n                    EventRuler.on(el, \"keypress\", EventHandlers.keypressEvent)), EventRuler.on(el, \"input\", EventHandlers.inputFallBackEvent), \r\n                    EventRuler.on(el, \"beforeinput\", EventHandlers.beforeInputEvent)), EventRuler.on(el, \"setvalue\", EventHandlers.setValueEvent), \r\n                    undoValue = getBufferTemplate().join(\"\"), \"\" !== el.inputmask._valueGet(!0) || !1 === opts.clearMaskOnLostFocus || document.activeElement === el)) {\r\n                        var initialValue = $.isFunction(opts.onBeforeMask) && opts.onBeforeMask.call(inputmask, el.inputmask._valueGet(!0), opts) || el.inputmask._valueGet(!0);\r\n                        \"\" !== initialValue && checkVal(el, !0, !1, initialValue.split(\"\"));\r\n                        var buffer = getBuffer().slice();\r\n                        undoValue = buffer.join(\"\"), !1 === isComplete(buffer) && opts.clearIncomplete && resetMaskSet(), \r\n                        opts.clearMaskOnLostFocus && document.activeElement !== el && (-1 === getLastValidPosition() ? buffer = [] : clearOptionalTail(buffer)), \r\n                        (!1 === opts.clearMaskOnLostFocus || opts.showMaskOnFocus && document.activeElement === el || \"\" !== el.inputmask._valueGet(!0)) && writeBuffer(el, buffer), \r\n                        document.activeElement === el && caret(el, seekNext(getLastValidPosition()));\r\n                    }\r\n                }(el);\r\n                break;\r\n\r\n              case \"format\":\r\n                return valueBuffer = ($.isFunction(opts.onBeforeMask) && opts.onBeforeMask.call(inputmask, actionObj.value, opts) || actionObj.value).split(\"\"), \r\n                checkVal.call(this, undefined, !0, !1, valueBuffer), actionObj.metadata ? {\r\n                    value: isRTL ? getBuffer().slice().reverse().join(\"\") : getBuffer().join(\"\"),\r\n                    metadata: maskScope.call(this, {\r\n                        action: \"getmetadata\"\r\n                    }, maskset, opts)\r\n                } : isRTL ? getBuffer().slice().reverse().join(\"\") : getBuffer().join(\"\");\r\n\r\n              case \"isValid\":\r\n                actionObj.value ? (valueBuffer = actionObj.value.split(\"\"), checkVal.call(this, undefined, !0, !0, valueBuffer)) : actionObj.value = getBuffer().join(\"\");\r\n                for (var buffer = getBuffer(), rl = determineLastRequiredPosition(), lmib = buffer.length - 1; lmib > rl && !isMask(lmib); lmib--) ;\r\n                return buffer.splice(rl, lmib + 1 - rl), isComplete(buffer) && actionObj.value === getBuffer().join(\"\");\r\n\r\n              case \"getemptymask\":\r\n                return getBufferTemplate().join(\"\");\r\n\r\n              case \"remove\":\r\n                return el && el.inputmask && ($.data(el, \"_inputmask_opts\", null), $el = $(el), \r\n                el.inputmask._valueSet(opts.autoUnmask ? unmaskedvalue(el) : el.inputmask._valueGet(!0)), \r\n                EventRuler.off(el), el.inputmask.colorMask && ((colorMask = el.inputmask.colorMask).removeChild(el), \r\n                colorMask.parentNode.insertBefore(el, colorMask), colorMask.parentNode.removeChild(colorMask)), \r\n                Object.getOwnPropertyDescriptor && Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(el), \"value\") && el.inputmask.__valueGet && Object.defineProperty(el, \"value\", {\r\n                    get: el.inputmask.__valueGet,\r\n                    set: el.inputmask.__valueSet,\r\n                    configurable: !0\r\n                }) : document.__lookupGetter__ && el.__lookupGetter__(\"value\") && el.inputmask.__valueGet && (el.__defineGetter__(\"value\", el.inputmask.__valueGet), \r\n                el.__defineSetter__(\"value\", el.inputmask.__valueSet)), el.inputmask = undefined), \r\n                el;\r\n\r\n              case \"getmetadata\":\r\n                if ($.isArray(maskset.metadata)) {\r\n                    var maskTarget = getMaskTemplate(!0, 0, !1).join(\"\");\r\n                    return $.each(maskset.metadata, function(ndx, mtdt) {\r\n                        if (mtdt.mask === maskTarget) return maskTarget = mtdt, !1;\r\n                    }), maskTarget;\r\n                }\r\n                return maskset.metadata;\r\n            }\r\n        }\r\n        return Inputmask.prototype = {\r\n            dataAttribute: \"data-inputmask\",\r\n            defaults: {\r\n                placeholder: \"_\",\r\n                optionalmarker: [ \"[\", \"]\" ],\r\n                quantifiermarker: [ \"{\", \"}\" ],\r\n                groupmarker: [ \"(\", \")\" ],\r\n                alternatormarker: \"|\",\r\n                escapeChar: \"\\\\\",\r\n                mask: null,\r\n                regex: null,\r\n                oncomplete: $.noop,\r\n                onincomplete: $.noop,\r\n                oncleared: $.noop,\r\n                repeat: 0,\r\n                greedy: !1,\r\n                autoUnmask: !1,\r\n                removeMaskOnSubmit: !1,\r\n                clearMaskOnLostFocus: !0,\r\n                insertMode: !0,\r\n                clearIncomplete: !1,\r\n                alias: null,\r\n                onKeyDown: $.noop,\r\n                onBeforeMask: null,\r\n                onBeforePaste: function(pastedValue, opts) {\r\n                    return $.isFunction(opts.onBeforeMask) ? opts.onBeforeMask.call(this, pastedValue, opts) : pastedValue;\r\n                },\r\n                onBeforeWrite: null,\r\n                onUnMask: null,\r\n                showMaskOnFocus: !0,\r\n                showMaskOnHover: !0,\r\n                onKeyValidation: $.noop,\r\n                skipOptionalPartCharacter: \" \",\r\n                numericInput: !1,\r\n                rightAlign: !1,\r\n                undoOnEscape: !0,\r\n                radixPoint: \"\",\r\n                _radixDance: !1,\r\n                groupSeparator: \"\",\r\n                keepStatic: null,\r\n                positionCaretOnTab: !0,\r\n                tabThrough: !1,\r\n                supportsInputType: [ \"text\", \"tel\", \"password\", \"search\" ],\r\n                ignorables: [ 8, 9, 13, 19, 27, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 0, 229 ],\r\n                isComplete: null,\r\n                preValidation: null,\r\n                postValidation: null,\r\n                staticDefinitionSymbol: undefined,\r\n                jitMasking: !1,\r\n                nullable: !0,\r\n                inputEventOnly: !1,\r\n                noValuePatching: !1,\r\n                positionCaretOnClick: \"lvp\",\r\n                casing: null,\r\n                inputmode: \"verbatim\",\r\n                colorMask: !1,\r\n                disablePredictiveText: !1,\r\n                importDataAttributes: !0\r\n            },\r\n            definitions: {\r\n                9: {\r\n                    validator: \"[0-9１-９]\",\r\n                    definitionSymbol: \"*\"\r\n                },\r\n                a: {\r\n                    validator: \"[A-Za-zА-яЁёÀ-ÿµ]\",\r\n                    definitionSymbol: \"*\"\r\n                },\r\n                \"*\": {\r\n                    validator: \"[0-9１-９A-Za-zА-яЁёÀ-ÿµ]\"\r\n                }\r\n            },\r\n            aliases: {},\r\n            masksCache: {},\r\n            mask: function(elems) {\r\n                var that = this;\r\n                return \"string\" == typeof elems && (elems = document.getElementById(elems) || document.querySelectorAll(elems)), \r\n                elems = elems.nodeName ? [ elems ] : elems, $.each(elems, function(ndx, el) {\r\n                    var scopedOpts = $.extend(!0, {}, that.opts);\r\n                    if (function(npt, opts, userOptions, dataAttribute) {\r\n                        if (!0 === opts.importDataAttributes) {\r\n                            var option, dataoptions, optionData, p, importOption = function(option, optionData) {\r\n                                null !== (optionData = optionData !== undefined ? optionData : npt.getAttribute(dataAttribute + \"-\" + option)) && (\"string\" == typeof optionData && (0 === option.indexOf(\"on\") ? optionData = window[optionData] : \"false\" === optionData ? optionData = !1 : \"true\" === optionData && (optionData = !0)), \r\n                                userOptions[option] = optionData);\r\n                            }, attrOptions = npt.getAttribute(dataAttribute);\r\n                            if (attrOptions && \"\" !== attrOptions && (attrOptions = attrOptions.replace(/'/g, '\"'), \r\n                            dataoptions = JSON.parse(\"{\" + attrOptions + \"}\")), dataoptions) for (p in optionData = undefined, \r\n                            dataoptions) if (\"alias\" === p.toLowerCase()) {\r\n                                optionData = dataoptions[p];\r\n                                break;\r\n                            }\r\n                            for (option in importOption(\"alias\", optionData), userOptions.alias && resolveAlias(userOptions.alias, userOptions, opts), \r\n                            opts) {\r\n                                if (dataoptions) for (p in optionData = undefined, dataoptions) if (p.toLowerCase() === option.toLowerCase()) {\r\n                                    optionData = dataoptions[p];\r\n                                    break;\r\n                                }\r\n                                importOption(option, optionData);\r\n                            }\r\n                        }\r\n                        return $.extend(!0, opts, userOptions), (\"rtl\" === npt.dir || opts.rightAlign) && (npt.style.textAlign = \"right\"), \r\n                        (\"rtl\" === npt.dir || opts.numericInput) && (npt.dir = \"ltr\", npt.removeAttribute(\"dir\"), \r\n                        opts.isRTL = !0), Object.keys(userOptions).length;\r\n                    }(el, scopedOpts, $.extend(!0, {}, that.userOptions), that.dataAttribute)) {\r\n                        var maskset = generateMaskSet(scopedOpts, that.noMasksCache);\r\n                        maskset !== undefined && (el.inputmask !== undefined && (el.inputmask.opts.autoUnmask = !0, \r\n                        el.inputmask.remove()), el.inputmask = new Inputmask(undefined, undefined, !0), \r\n                        el.inputmask.opts = scopedOpts, el.inputmask.noMasksCache = that.noMasksCache, el.inputmask.userOptions = $.extend(!0, {}, that.userOptions), \r\n                        el.inputmask.isRTL = scopedOpts.isRTL || scopedOpts.numericInput, el.inputmask.el = el, \r\n                        el.inputmask.maskset = maskset, $.data(el, \"_inputmask_opts\", scopedOpts), maskScope.call(el.inputmask, {\r\n                            action: \"mask\"\r\n                        }));\r\n                    }\r\n                }), elems && elems[0] && elems[0].inputmask || this;\r\n            },\r\n            option: function(options, noremask) {\r\n                return \"string\" == typeof options ? this.opts[options] : \"object\" === (void 0 === options ? \"undefined\" : _typeof(options)) ? ($.extend(this.userOptions, options), \r\n                this.el && !0 !== noremask && this.mask(this.el), this) : void 0;\r\n            },\r\n            unmaskedvalue: function(value) {\r\n                return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache), \r\n                maskScope.call(this, {\r\n                    action: \"unmaskedvalue\",\r\n                    value: value\r\n                });\r\n            },\r\n            remove: function() {\r\n                return maskScope.call(this, {\r\n                    action: \"remove\"\r\n                });\r\n            },\r\n            getemptymask: function() {\r\n                return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache), \r\n                maskScope.call(this, {\r\n                    action: \"getemptymask\"\r\n                });\r\n            },\r\n            hasMaskedValue: function() {\r\n                return !this.opts.autoUnmask;\r\n            },\r\n            isComplete: function() {\r\n                return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache), \r\n                maskScope.call(this, {\r\n                    action: \"isComplete\"\r\n                });\r\n            },\r\n            getmetadata: function() {\r\n                return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache), \r\n                maskScope.call(this, {\r\n                    action: \"getmetadata\"\r\n                });\r\n            },\r\n            isValid: function(value) {\r\n                return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache), \r\n                maskScope.call(this, {\r\n                    action: \"isValid\",\r\n                    value: value\r\n                });\r\n            },\r\n            format: function(value, metadata) {\r\n                return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache), \r\n                maskScope.call(this, {\r\n                    action: \"format\",\r\n                    value: value,\r\n                    metadata: metadata\r\n                });\r\n            },\r\n            setValue: function(value) {\r\n                this.el && $(this.el).trigger(\"setvalue\", [ value ]);\r\n            },\r\n            analyseMask: function(mask, regexMask, opts) {\r\n                var match, m, openingToken, currentOpeningToken, alternator, lastMatch, tokenizer = /(?:[?*+]|\\{[0-9\\+\\*]+(?:,[0-9\\+\\*]*)?(?:\\|[0-9\\+\\*]*)?\\})|[^.?*+^${[]()|\\\\]+|./g, regexTokenizer = /\\[\\^?]?(?:[^\\\\\\]]+|\\\\[\\S\\s]?)*]?|\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\\S\\s]?)|\\((?:\\?[:=!]?)?|(?:[?*+]|\\{[0-9]+(?:,[0-9]*)?\\})\\??|[^.?*+^${[()|\\\\]+|./g, escaped = !1, currentToken = new MaskToken(), openenings = [], maskTokens = [];\r\n                function MaskToken(isGroup, isOptional, isQuantifier, isAlternator) {\r\n                    this.matches = [], this.openGroup = isGroup || !1, this.alternatorGroup = !1, this.isGroup = isGroup || !1, \r\n                    this.isOptional = isOptional || !1, this.isQuantifier = isQuantifier || !1, this.isAlternator = isAlternator || !1, \r\n                    this.quantifier = {\r\n                        min: 1,\r\n                        max: 1\r\n                    };\r\n                }\r\n                function insertTestDefinition(mtoken, element, position) {\r\n                    position = position !== undefined ? position : mtoken.matches.length;\r\n                    var prevMatch = mtoken.matches[position - 1];\r\n                    if (regexMask) 0 === element.indexOf(\"[\") || escaped && /\\\\d|\\\\s|\\\\w]/i.test(element) || \".\" === element ? mtoken.matches.splice(position++, 0, {\r\n                        fn: new RegExp(element, opts.casing ? \"i\" : \"\"),\r\n                        optionality: !1,\r\n                        newBlockMarker: prevMatch === undefined ? \"master\" : prevMatch.def !== element,\r\n                        casing: null,\r\n                        def: element,\r\n                        placeholder: undefined,\r\n                        nativeDef: element\r\n                    }) : (escaped && (element = element[element.length - 1]), $.each(element.split(\"\"), function(ndx, lmnt) {\r\n                        prevMatch = mtoken.matches[position - 1], mtoken.matches.splice(position++, 0, {\r\n                            fn: null,\r\n                            optionality: !1,\r\n                            newBlockMarker: prevMatch === undefined ? \"master\" : prevMatch.def !== lmnt && null !== prevMatch.fn,\r\n                            casing: null,\r\n                            def: opts.staticDefinitionSymbol || lmnt,\r\n                            placeholder: opts.staticDefinitionSymbol !== undefined ? lmnt : undefined,\r\n                            nativeDef: (escaped ? \"'\" : \"\") + lmnt\r\n                        });\r\n                    })), escaped = !1; else {\r\n                        var maskdef = (opts.definitions ? opts.definitions[element] : undefined) || Inputmask.prototype.definitions[element];\r\n                        maskdef && !escaped ? mtoken.matches.splice(position++, 0, {\r\n                            fn: maskdef.validator ? \"string\" == typeof maskdef.validator ? new RegExp(maskdef.validator, opts.casing ? \"i\" : \"\") : new function() {\r\n                                this.test = maskdef.validator;\r\n                            }() : new RegExp(\".\"),\r\n                            optionality: !1,\r\n                            newBlockMarker: prevMatch === undefined ? \"master\" : prevMatch.def !== (maskdef.definitionSymbol || element),\r\n                            casing: maskdef.casing,\r\n                            def: maskdef.definitionSymbol || element,\r\n                            placeholder: maskdef.placeholder,\r\n                            nativeDef: element\r\n                        }) : (mtoken.matches.splice(position++, 0, {\r\n                            fn: null,\r\n                            optionality: !1,\r\n                            newBlockMarker: prevMatch === undefined ? \"master\" : prevMatch.def !== element && null !== prevMatch.fn,\r\n                            casing: null,\r\n                            def: opts.staticDefinitionSymbol || element,\r\n                            placeholder: opts.staticDefinitionSymbol !== undefined ? element : undefined,\r\n                            nativeDef: (escaped ? \"'\" : \"\") + element\r\n                        }), escaped = !1);\r\n                    }\r\n                }\r\n                function defaultCase() {\r\n                    if (openenings.length > 0) {\r\n                        if (insertTestDefinition(currentOpeningToken = openenings[openenings.length - 1], m), \r\n                        currentOpeningToken.isAlternator) {\r\n                            alternator = openenings.pop();\r\n                            for (var mndx = 0; mndx < alternator.matches.length; mndx++) alternator.matches[mndx].isGroup && (alternator.matches[mndx].isGroup = !1);\r\n                            openenings.length > 0 ? (currentOpeningToken = openenings[openenings.length - 1]).matches.push(alternator) : currentToken.matches.push(alternator);\r\n                        }\r\n                    } else insertTestDefinition(currentToken, m);\r\n                }\r\n                function groupify(matches) {\r\n                    var groupToken = new MaskToken(!0);\r\n                    return groupToken.openGroup = !1, groupToken.matches = matches, groupToken;\r\n                }\r\n                for (regexMask && (opts.optionalmarker[0] = undefined, opts.optionalmarker[1] = undefined); match = regexMask ? regexTokenizer.exec(mask) : tokenizer.exec(mask); ) {\r\n                    if (m = match[0], regexMask) switch (m.charAt(0)) {\r\n                      case \"?\":\r\n                        m = \"{0,1}\";\r\n                        break;\r\n\r\n                      case \"+\":\r\n                      case \"*\":\r\n                        m = \"{\" + m + \"}\";\r\n                    }\r\n                    if (escaped) defaultCase(); else switch (m.charAt(0)) {\r\n                      case \"(?=\":\r\n                      case \"(?!\":\r\n                      case \"(?<=\":\r\n                      case \"(?<!\":\r\n                        break;\r\n\r\n                      case opts.escapeChar:\r\n                        escaped = !0, regexMask && defaultCase();\r\n                        break;\r\n\r\n                      case opts.optionalmarker[1]:\r\n                      case opts.groupmarker[1]:\r\n                        if ((openingToken = openenings.pop()).openGroup = !1, openingToken !== undefined) if (openenings.length > 0) {\r\n                            if ((currentOpeningToken = openenings[openenings.length - 1]).matches.push(openingToken), \r\n                            currentOpeningToken.isAlternator) {\r\n                                alternator = openenings.pop();\r\n                                for (var mndx = 0; mndx < alternator.matches.length; mndx++) alternator.matches[mndx].isGroup = !1, \r\n                                alternator.matches[mndx].alternatorGroup = !1;\r\n                                openenings.length > 0 ? (currentOpeningToken = openenings[openenings.length - 1]).matches.push(alternator) : currentToken.matches.push(alternator);\r\n                            }\r\n                        } else currentToken.matches.push(openingToken); else defaultCase();\r\n                        break;\r\n\r\n                      case opts.optionalmarker[0]:\r\n                        openenings.push(new MaskToken(!1, !0));\r\n                        break;\r\n\r\n                      case opts.groupmarker[0]:\r\n                        openenings.push(new MaskToken(!0));\r\n                        break;\r\n\r\n                      case opts.quantifiermarker[0]:\r\n                        var quantifier = new MaskToken(!1, !1, !0), mqj = (m = m.replace(/[{}]/g, \"\")).split(\"|\"), mq = mqj[0].split(\",\"), mq0 = isNaN(mq[0]) ? mq[0] : parseInt(mq[0]), mq1 = 1 === mq.length ? mq0 : isNaN(mq[1]) ? mq[1] : parseInt(mq[1]);\r\n                        \"*\" !== mq0 && \"+\" !== mq0 || (mq0 = \"*\" === mq1 ? 0 : 1), quantifier.quantifier = {\r\n                            min: mq0,\r\n                            max: mq1,\r\n                            jit: mqj[1]\r\n                        };\r\n                        var matches = openenings.length > 0 ? openenings[openenings.length - 1].matches : currentToken.matches;\r\n                        if ((match = matches.pop()).isAlternator) {\r\n                            matches.push(match), matches = match.matches;\r\n                            var groupToken = new MaskToken(!0), tmpMatch = matches.pop();\r\n                            matches.push(groupToken), matches = groupToken.matches, match = tmpMatch;\r\n                        }\r\n                        match.isGroup || (match = groupify([ match ])), matches.push(match), matches.push(quantifier);\r\n                        break;\r\n\r\n                      case opts.alternatormarker:\r\n                        var groupQuantifier = function(matches) {\r\n                            var lastMatch = matches.pop();\r\n                            return lastMatch.isQuantifier && (lastMatch = groupify([ matches.pop(), lastMatch ])), \r\n                            lastMatch;\r\n                        };\r\n                        if (openenings.length > 0) {\r\n                            var subToken = (currentOpeningToken = openenings[openenings.length - 1]).matches[currentOpeningToken.matches.length - 1];\r\n                            lastMatch = currentOpeningToken.openGroup && (subToken.matches === undefined || !1 === subToken.isGroup && !1 === subToken.isAlternator) ? openenings.pop() : groupQuantifier(currentOpeningToken.matches);\r\n                        } else lastMatch = groupQuantifier(currentToken.matches);\r\n                        if (lastMatch.isAlternator) openenings.push(lastMatch); else if (lastMatch.alternatorGroup ? (alternator = openenings.pop(), \r\n                        lastMatch.alternatorGroup = !1) : alternator = new MaskToken(!1, !1, !1, !0), alternator.matches.push(lastMatch), \r\n                        openenings.push(alternator), lastMatch.openGroup) {\r\n                            lastMatch.openGroup = !1;\r\n                            var alternatorGroup = new MaskToken(!0);\r\n                            alternatorGroup.alternatorGroup = !0, openenings.push(alternatorGroup);\r\n                        }\r\n                        break;\r\n\r\n                      default:\r\n                        defaultCase();\r\n                    }\r\n                }\r\n                for (;openenings.length > 0; ) openingToken = openenings.pop(), currentToken.matches.push(openingToken);\r\n                return currentToken.matches.length > 0 && (function verifyGroupMarker(maskToken) {\r\n                    maskToken && maskToken.matches && $.each(maskToken.matches, function(ndx, token) {\r\n                        var nextToken = maskToken.matches[ndx + 1];\r\n                        (nextToken === undefined || nextToken.matches === undefined || !1 === nextToken.isQuantifier) && token && token.isGroup && (token.isGroup = !1, \r\n                        regexMask || (insertTestDefinition(token, opts.groupmarker[0], 0), !0 !== token.openGroup && insertTestDefinition(token, opts.groupmarker[1]))), \r\n                        verifyGroupMarker(token);\r\n                    });\r\n                }(currentToken), maskTokens.push(currentToken)), (opts.numericInput || opts.isRTL) && function reverseTokens(maskToken) {\r\n                    for (var match in maskToken.matches = maskToken.matches.reverse(), maskToken.matches) if (maskToken.matches.hasOwnProperty(match)) {\r\n                        var intMatch = parseInt(match);\r\n                        if (maskToken.matches[match].isQuantifier && maskToken.matches[intMatch + 1] && maskToken.matches[intMatch + 1].isGroup) {\r\n                            var qt = maskToken.matches[match];\r\n                            maskToken.matches.splice(match, 1), maskToken.matches.splice(intMatch + 1, 0, qt);\r\n                        }\r\n                        maskToken.matches[match].matches !== undefined ? maskToken.matches[match] = reverseTokens(maskToken.matches[match]) : maskToken.matches[match] = ((st = maskToken.matches[match]) === opts.optionalmarker[0] ? st = opts.optionalmarker[1] : st === opts.optionalmarker[1] ? st = opts.optionalmarker[0] : st === opts.groupmarker[0] ? st = opts.groupmarker[1] : st === opts.groupmarker[1] && (st = opts.groupmarker[0]), \r\n                        st);\r\n                    }\r\n                    var st;\r\n                    return maskToken;\r\n                }(maskTokens[0]), maskTokens;\r\n            }\r\n        }, Inputmask.extendDefaults = function(options) {\r\n            $.extend(!0, Inputmask.prototype.defaults, options);\r\n        }, Inputmask.extendDefinitions = function(definition) {\r\n            $.extend(!0, Inputmask.prototype.definitions, definition);\r\n        }, Inputmask.extendAliases = function(alias) {\r\n            $.extend(!0, Inputmask.prototype.aliases, alias);\r\n        }, Inputmask.format = function(value, options, metadata) {\r\n            return Inputmask(options).format(value, metadata);\r\n        }, Inputmask.unmask = function(value, options) {\r\n            return Inputmask(options).unmaskedvalue(value);\r\n        }, Inputmask.isValid = function(value, options) {\r\n            return Inputmask(options).isValid(value);\r\n        }, Inputmask.remove = function(elems) {\r\n            \"string\" == typeof elems && (elems = document.getElementById(elems) || document.querySelectorAll(elems)), \r\n            elems = elems.nodeName ? [ elems ] : elems, $.each(elems, function(ndx, el) {\r\n                el.inputmask && el.inputmask.remove();\r\n            });\r\n        }, Inputmask.setValue = function(elems, value) {\r\n            \"string\" == typeof elems && (elems = document.getElementById(elems) || document.querySelectorAll(elems)), \r\n            elems = elems.nodeName ? [ elems ] : elems, $.each(elems, function(ndx, el) {\r\n                el.inputmask ? el.inputmask.setValue(value) : $(el).trigger(\"setvalue\", [ value ]);\r\n            });\r\n        }, Inputmask.escapeRegex = function(str) {\r\n            return str.replace(new RegExp(\"(\\\\\" + [ \"/\", \".\", \"*\", \"+\", \"?\", \"|\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", \"\\\\\", \"$\", \"^\" ].join(\"|\\\\\") + \")\", \"gim\"), \"\\\\$1\");\r\n        }, Inputmask.keyCode = {\r\n            BACKSPACE: 8,\r\n            BACKSPACE_SAFARI: 127,\r\n            DELETE: 46,\r\n            DOWN: 40,\r\n            END: 35,\r\n            ENTER: 13,\r\n            ESCAPE: 27,\r\n            HOME: 36,\r\n            INSERT: 45,\r\n            LEFT: 37,\r\n            PAGE_DOWN: 34,\r\n            PAGE_UP: 33,\r\n            RIGHT: 39,\r\n            SPACE: 32,\r\n            TAB: 9,\r\n            UP: 38,\r\n            X: 88,\r\n            CONTROL: 17\r\n        }, Inputmask;\r\n    }) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);\r\n}, function(module, exports, __webpack_require__) {\r\n    \"use strict\";\r\n    var __WEBPACK_AMD_DEFINE_RESULT__;\r\n    \"function\" == typeof Symbol && Symbol.iterator;\r\n    void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = function() {\r\n        return window;\r\n    }.call(exports, __webpack_require__, exports, module)) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);\r\n}, function(module, exports, __webpack_require__) {\r\n    \"use strict\";\r\n    var __WEBPACK_AMD_DEFINE_RESULT__;\r\n    \"function\" == typeof Symbol && Symbol.iterator;\r\n    void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = function() {\r\n        return document;\r\n    }.call(exports, __webpack_require__, exports, module)) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);\r\n}, function(module, exports, __webpack_require__) {\r\n    \"use strict\";\r\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\r\n    \"function\" == typeof Symbol && Symbol.iterator;\r\n    __WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(2), __webpack_require__(4) ], \r\n    void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = \"function\" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = function($, Inputmask) {\r\n        return Inputmask.extendDefinitions({\r\n            A: {\r\n                validator: \"[A-Za-zА-яЁёÀ-ÿµ]\",\r\n                casing: \"upper\"\r\n            },\r\n            \"&\": {\r\n                validator: \"[0-9A-Za-zА-яЁёÀ-ÿµ]\",\r\n                casing: \"upper\"\r\n            },\r\n            \"#\": {\r\n                validator: \"[0-9A-Fa-f]\",\r\n                casing: \"upper\"\r\n            }\r\n        }), Inputmask.extendAliases({\r\n            cssunit: {\r\n                regex: \"[+-]?[0-9]+\\\\.?([0-9]+)?(px|em|rem|ex|%|in|cm|mm|pt|pc)\"\r\n            },\r\n            url: {\r\n                regex: \"(https?|ftp)//.*\",\r\n                autoUnmask: !1\r\n            },\r\n            ip: {\r\n                mask: \"i[i[i]].i[i[i]].i[i[i]].i[i[i]]\",\r\n                definitions: {\r\n                    i: {\r\n                        validator: function(chrs, maskset, pos, strict, opts) {\r\n                            return pos - 1 > -1 && \".\" !== maskset.buffer[pos - 1] ? (chrs = maskset.buffer[pos - 1] + chrs, \r\n                            chrs = pos - 2 > -1 && \".\" !== maskset.buffer[pos - 2] ? maskset.buffer[pos - 2] + chrs : \"0\" + chrs) : chrs = \"00\" + chrs, \r\n                            new RegExp(\"25[0-5]|2[0-4][0-9]|[01][0-9][0-9]\").test(chrs);\r\n                        }\r\n                    }\r\n                },\r\n                onUnMask: function(maskedValue, unmaskedValue, opts) {\r\n                    return maskedValue;\r\n                },\r\n                inputmode: \"numeric\"\r\n            },\r\n            email: {\r\n                mask: \"*{1,64}[.*{1,64}][.*{1,64}][.*{1,63}]@-{1,63}.-{1,63}[.-{1,63}][.-{1,63}]\",\r\n                greedy: !1,\r\n                casing: \"lower\",\r\n                onBeforePaste: function(pastedValue, opts) {\r\n                    return (pastedValue = pastedValue.toLowerCase()).replace(\"mailto:\", \"\");\r\n                },\r\n                definitions: {\r\n                    \"*\": {\r\n                        validator: \"[0-9１-９A-Za-zА-яЁёÀ-ÿµ!#$%&'*+/=?^_`{|}~-]\"\r\n                    },\r\n                    \"-\": {\r\n                        validator: \"[0-9A-Za-z-]\"\r\n                    }\r\n                },\r\n                onUnMask: function(maskedValue, unmaskedValue, opts) {\r\n                    return maskedValue;\r\n                },\r\n                inputmode: \"email\"\r\n            },\r\n            mac: {\r\n                mask: \"##:##:##:##:##:##\"\r\n            },\r\n            vin: {\r\n                mask: \"V{13}9{4}\",\r\n                definitions: {\r\n                    V: {\r\n                        validator: \"[A-HJ-NPR-Za-hj-npr-z\\\\d]\",\r\n                        casing: \"upper\"\r\n                    }\r\n                },\r\n                clearIncomplete: !0,\r\n                autoUnmask: !0\r\n            }\r\n        }), Inputmask;\r\n    }) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);\r\n}, function(module, exports, __webpack_require__) {\r\n    \"use strict\";\r\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\r\n    \"function\" == typeof Symbol && Symbol.iterator;\r\n    __WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(2), __webpack_require__(4) ], \r\n    void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = \"function\" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = function($, Inputmask, undefined) {\r\n        function autoEscape(txt, opts) {\r\n            for (var escapedTxt = \"\", i = 0; i < txt.length; i++) Inputmask.prototype.definitions[txt.charAt(i)] || opts.definitions[txt.charAt(i)] || opts.optionalmarker.start === txt.charAt(i) || opts.optionalmarker.end === txt.charAt(i) || opts.quantifiermarker.start === txt.charAt(i) || opts.quantifiermarker.end === txt.charAt(i) || opts.groupmarker.start === txt.charAt(i) || opts.groupmarker.end === txt.charAt(i) || opts.alternatormarker === txt.charAt(i) ? escapedTxt += \"\\\\\" + txt.charAt(i) : escapedTxt += txt.charAt(i);\r\n            return escapedTxt;\r\n        }\r\n        return Inputmask.extendAliases({\r\n            numeric: {\r\n                mask: function(opts) {\r\n                    if (0 !== opts.repeat && isNaN(opts.integerDigits) && (opts.integerDigits = opts.repeat), \r\n                    opts.repeat = 0, opts.groupSeparator === opts.radixPoint && opts.digits && \"0\" !== opts.digits && (\".\" === opts.radixPoint ? opts.groupSeparator = \",\" : \",\" === opts.radixPoint ? opts.groupSeparator = \".\" : opts.groupSeparator = \"\"), \r\n                    \" \" === opts.groupSeparator && (opts.skipOptionalPartCharacter = undefined), opts.autoGroup = opts.autoGroup && \"\" !== opts.groupSeparator, \r\n                    opts.autoGroup && (\"string\" == typeof opts.groupSize && isFinite(opts.groupSize) && (opts.groupSize = parseInt(opts.groupSize)), \r\n                    isFinite(opts.integerDigits))) {\r\n                        var seps = Math.floor(opts.integerDigits / opts.groupSize), mod = opts.integerDigits % opts.groupSize;\r\n                        opts.integerDigits = parseInt(opts.integerDigits) + (0 === mod ? seps - 1 : seps), \r\n                        opts.integerDigits < 1 && (opts.integerDigits = \"*\");\r\n                    }\r\n                    opts.placeholder.length > 1 && (opts.placeholder = opts.placeholder.charAt(0)), \r\n                    \"radixFocus\" === opts.positionCaretOnClick && \"\" === opts.placeholder && !1 === opts.integerOptional && (opts.positionCaretOnClick = \"lvp\"), \r\n                    opts.definitions[\";\"] = opts.definitions[\"~\"], opts.definitions[\";\"].definitionSymbol = \"~\", \r\n                    !0 === opts.numericInput && (opts.positionCaretOnClick = \"radixFocus\" === opts.positionCaretOnClick ? \"lvp\" : opts.positionCaretOnClick, \r\n                    opts.digitsOptional = !1, isNaN(opts.digits) && (opts.digits = 2), opts.decimalProtect = !1);\r\n                    var mask = \"[+]\";\r\n                    if (mask += autoEscape(opts.prefix, opts), !0 === opts.integerOptional ? mask += \"~{1,\" + opts.integerDigits + \"}\" : mask += \"~{\" + opts.integerDigits + \"}\", \r\n                    opts.digits !== undefined) {\r\n                        var radixDef = opts.decimalProtect ? \":\" : opts.radixPoint, dq = opts.digits.toString().split(\",\");\r\n                        isFinite(dq[0]) && dq[1] && isFinite(dq[1]) ? mask += radixDef + \";{\" + opts.digits + \"}\" : (isNaN(opts.digits) || parseInt(opts.digits) > 0) && (opts.digitsOptional ? mask += \"[\" + radixDef + \";{1,\" + opts.digits + \"}]\" : mask += radixDef + \";{\" + opts.digits + \"}\");\r\n                    }\r\n                    return mask += autoEscape(opts.suffix, opts), mask += \"[-]\", opts.greedy = !1, mask;\r\n                },\r\n                placeholder: \"\",\r\n                greedy: !1,\r\n                digits: \"*\",\r\n                digitsOptional: !0,\r\n                enforceDigitsOnBlur: !1,\r\n                radixPoint: \".\",\r\n                positionCaretOnClick: \"radixFocus\",\r\n                groupSize: 3,\r\n                groupSeparator: \"\",\r\n                autoGroup: !1,\r\n                allowMinus: !0,\r\n                negationSymbol: {\r\n                    front: \"-\",\r\n                    back: \"\"\r\n                },\r\n                integerDigits: \"+\",\r\n                integerOptional: !0,\r\n                prefix: \"\",\r\n                suffix: \"\",\r\n                rightAlign: !0,\r\n                decimalProtect: !0,\r\n                min: null,\r\n                max: null,\r\n                step: 1,\r\n                insertMode: !0,\r\n                autoUnmask: !1,\r\n                unmaskAsNumber: !1,\r\n                inputmode: \"numeric\",\r\n                preValidation: function(buffer, pos, c, isSelection, opts, maskset) {\r\n                    if (\"-\" === c || c === opts.negationSymbol.front) return !0 === opts.allowMinus && (opts.isNegative = opts.isNegative === undefined || !opts.isNegative, \r\n                    \"\" === buffer.join(\"\") || {\r\n                        caret: pos,\r\n                        dopost: !0\r\n                    });\r\n                    if (!1 === isSelection && c === opts.radixPoint && opts.digits !== undefined && (isNaN(opts.digits) || parseInt(opts.digits) > 0)) {\r\n                        var radixPos = $.inArray(opts.radixPoint, buffer);\r\n                        if (-1 !== radixPos && maskset.validPositions[radixPos] !== undefined) return !0 === opts.numericInput ? pos === radixPos : {\r\n                            caret: radixPos + 1\r\n                        };\r\n                    }\r\n                    return !0;\r\n                },\r\n                postValidation: function(buffer, currentResult, opts) {\r\n                    var suffix = opts.suffix.split(\"\"), prefix = opts.prefix.split(\"\");\r\n                    if (currentResult.pos === undefined && currentResult.caret !== undefined && !0 !== currentResult.dopost) return currentResult;\r\n                    var caretPos = currentResult.caret !== undefined ? currentResult.caret : currentResult.pos, maskedValue = buffer.slice();\r\n                    opts.numericInput && (caretPos = maskedValue.length - caretPos - 1, maskedValue = maskedValue.reverse());\r\n                    var charAtPos = maskedValue[caretPos];\r\n                    if (charAtPos === opts.groupSeparator && (charAtPos = maskedValue[caretPos += 1]), \r\n                    caretPos === maskedValue.length - opts.suffix.length - 1 && charAtPos === opts.radixPoint) return currentResult;\r\n                    charAtPos !== undefined && charAtPos !== opts.radixPoint && charAtPos !== opts.negationSymbol.front && charAtPos !== opts.negationSymbol.back && (maskedValue[caretPos] = \"?\", \r\n                    opts.prefix.length > 0 && caretPos >= (!1 === opts.isNegative ? 1 : 0) && caretPos < opts.prefix.length - 1 + (!1 === opts.isNegative ? 1 : 0) ? prefix[caretPos - (!1 === opts.isNegative ? 1 : 0)] = \"?\" : opts.suffix.length > 0 && caretPos >= maskedValue.length - opts.suffix.length - (!1 === opts.isNegative ? 1 : 0) && (suffix[caretPos - (maskedValue.length - opts.suffix.length - (!1 === opts.isNegative ? 1 : 0))] = \"?\")), \r\n                    prefix = prefix.join(\"\"), suffix = suffix.join(\"\");\r\n                    var processValue = maskedValue.join(\"\").replace(prefix, \"\");\r\n                    if (processValue = (processValue = (processValue = (processValue = processValue.replace(suffix, \"\")).replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\")).replace(new RegExp(\"[-\" + Inputmask.escapeRegex(opts.negationSymbol.front) + \"]\", \"g\"), \"\")).replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + \"$\"), \"\"), \r\n                    isNaN(opts.placeholder) && (processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.placeholder), \"g\"), \"\")), \r\n                    processValue.length > 1 && 1 !== processValue.indexOf(opts.radixPoint) && (\"0\" === charAtPos && (processValue = processValue.replace(/^\\?/g, \"\")), \r\n                    processValue = processValue.replace(/^0/g, \"\")), processValue.charAt(0) === opts.radixPoint && \"\" !== opts.radixPoint && !0 !== opts.numericInput && (processValue = \"0\" + processValue), \r\n                    \"\" !== processValue) {\r\n                        if (processValue = processValue.split(\"\"), (!opts.digitsOptional || opts.enforceDigitsOnBlur && \"blur\" === currentResult.event) && isFinite(opts.digits)) {\r\n                            var radixPosition = $.inArray(opts.radixPoint, processValue), rpb = $.inArray(opts.radixPoint, maskedValue);\r\n                            -1 === radixPosition && (processValue.push(opts.radixPoint), radixPosition = processValue.length - 1);\r\n                            for (var i = 1; i <= opts.digits; i++) opts.digitsOptional && (!opts.enforceDigitsOnBlur || \"blur\" !== currentResult.event) || processValue[radixPosition + i] !== undefined && processValue[radixPosition + i] !== opts.placeholder.charAt(0) ? -1 !== rpb && maskedValue[rpb + i] !== undefined && (processValue[radixPosition + i] = processValue[radixPosition + i] || maskedValue[rpb + i]) : processValue[radixPosition + i] = currentResult.placeholder || opts.placeholder.charAt(0);\r\n                        }\r\n                        if (!0 !== opts.autoGroup || \"\" === opts.groupSeparator || charAtPos === opts.radixPoint && currentResult.pos === undefined && !currentResult.dopost) processValue = processValue.join(\"\"); else {\r\n                            var addRadix = processValue[processValue.length - 1] === opts.radixPoint && currentResult.c === opts.radixPoint;\r\n                            processValue = Inputmask(function(buffer, opts) {\r\n                                var postMask = \"\";\r\n                                if (postMask += \"(\" + opts.groupSeparator + \"*{\" + opts.groupSize + \"}){*}\", \"\" !== opts.radixPoint) {\r\n                                    var radixSplit = buffer.join(\"\").split(opts.radixPoint);\r\n                                    radixSplit[1] && (postMask += opts.radixPoint + \"*{\" + radixSplit[1].match(/^\\d*\\??\\d*/)[0].length + \"}\");\r\n                                }\r\n                                return postMask;\r\n                            }(processValue, opts), {\r\n                                numericInput: !0,\r\n                                jitMasking: !0,\r\n                                definitions: {\r\n                                    \"*\": {\r\n                                        validator: \"[0-9?]\",\r\n                                        cardinality: 1\r\n                                    }\r\n                                }\r\n                            }).format(processValue.join(\"\")), addRadix && (processValue += opts.radixPoint), \r\n                            processValue.charAt(0) === opts.groupSeparator && processValue.substr(1);\r\n                        }\r\n                    }\r\n                    if (opts.isNegative && \"blur\" === currentResult.event && (opts.isNegative = \"0\" !== processValue), \r\n                    processValue = prefix + processValue, processValue += suffix, opts.isNegative && (processValue = opts.negationSymbol.front + processValue, \r\n                    processValue += opts.negationSymbol.back), processValue = processValue.split(\"\"), \r\n                    charAtPos !== undefined) if (charAtPos !== opts.radixPoint && charAtPos !== opts.negationSymbol.front && charAtPos !== opts.negationSymbol.back) (caretPos = $.inArray(\"?\", processValue)) > -1 ? processValue[caretPos] = charAtPos : caretPos = currentResult.caret || 0; else if (charAtPos === opts.radixPoint || charAtPos === opts.negationSymbol.front || charAtPos === opts.negationSymbol.back) {\r\n                        var newCaretPos = $.inArray(charAtPos, processValue);\r\n                        -1 !== newCaretPos && (caretPos = newCaretPos);\r\n                    }\r\n                    opts.numericInput && (caretPos = processValue.length - caretPos - 1, processValue = processValue.reverse());\r\n                    var rslt = {\r\n                        caret: charAtPos === undefined || currentResult.pos !== undefined ? caretPos + (opts.numericInput ? -1 : 1) : caretPos,\r\n                        buffer: processValue,\r\n                        refreshFromBuffer: currentResult.dopost || buffer.join(\"\") !== processValue.join(\"\")\r\n                    };\r\n                    return rslt.refreshFromBuffer ? rslt : currentResult;\r\n                },\r\n                onBeforeWrite: function(e, buffer, caretPos, opts) {\r\n                    if (e) switch (e.type) {\r\n                      case \"keydown\":\r\n                        return opts.postValidation(buffer, {\r\n                            caret: caretPos,\r\n                            dopost: !0\r\n                        }, opts);\r\n\r\n                      case \"blur\":\r\n                      case \"checkval\":\r\n                        var unmasked;\r\n                        if (function(opts) {\r\n                            opts.parseMinMaxOptions === undefined && (null !== opts.min && (opts.min = opts.min.toString().replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\"), \r\n                            \",\" === opts.radixPoint && (opts.min = opts.min.replace(opts.radixPoint, \".\")), \r\n                            opts.min = isFinite(opts.min) ? parseFloat(opts.min) : NaN, isNaN(opts.min) && (opts.min = Number.MIN_VALUE)), \r\n                            null !== opts.max && (opts.max = opts.max.toString().replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\"), \r\n                            \",\" === opts.radixPoint && (opts.max = opts.max.replace(opts.radixPoint, \".\")), \r\n                            opts.max = isFinite(opts.max) ? parseFloat(opts.max) : NaN, isNaN(opts.max) && (opts.max = Number.MAX_VALUE)), \r\n                            opts.parseMinMaxOptions = \"done\");\r\n                        }(opts), null !== opts.min || null !== opts.max) {\r\n                            if (unmasked = opts.onUnMask(buffer.join(\"\"), undefined, $.extend({}, opts, {\r\n                                unmaskAsNumber: !0\r\n                            })), null !== opts.min && unmasked < opts.min) return opts.isNegative = opts.min < 0, \r\n                            opts.postValidation(opts.min.toString().replace(\".\", opts.radixPoint).split(\"\"), {\r\n                                caret: caretPos,\r\n                                dopost: !0,\r\n                                placeholder: \"0\"\r\n                            }, opts);\r\n                            if (null !== opts.max && unmasked > opts.max) return opts.isNegative = opts.max < 0, \r\n                            opts.postValidation(opts.max.toString().replace(\".\", opts.radixPoint).split(\"\"), {\r\n                                caret: caretPos,\r\n                                dopost: !0,\r\n                                placeholder: \"0\"\r\n                            }, opts);\r\n                        }\r\n                        return opts.postValidation(buffer, {\r\n                            caret: caretPos,\r\n                            placeholder: \"0\",\r\n                            event: \"blur\"\r\n                        }, opts);\r\n\r\n                      case \"_checkval\":\r\n                        return {\r\n                            caret: caretPos\r\n                        };\r\n                    }\r\n                },\r\n                regex: {\r\n                    integerPart: function(opts, emptyCheck) {\r\n                        return emptyCheck ? new RegExp(\"[\" + Inputmask.escapeRegex(opts.negationSymbol.front) + \"+]?\") : new RegExp(\"[\" + Inputmask.escapeRegex(opts.negationSymbol.front) + \"+]?\\\\d+\");\r\n                    },\r\n                    integerNPart: function(opts) {\r\n                        return new RegExp(\"[\\\\d\" + Inputmask.escapeRegex(opts.groupSeparator) + Inputmask.escapeRegex(opts.placeholder.charAt(0)) + \"]+\");\r\n                    }\r\n                },\r\n                definitions: {\r\n                    \"~\": {\r\n                        validator: function(chrs, maskset, pos, strict, opts, isSelection) {\r\n                            var isValid;\r\n                            if (\"k\" === chrs || \"m\" === chrs) {\r\n                                isValid = {\r\n                                    insert: [],\r\n                                    c: 0\r\n                                };\r\n                                for (var i = 0, l = \"k\" === chrs ? 2 : 5; i < l; i++) isValid.insert.push({\r\n                                    pos: pos + i,\r\n                                    c: 0\r\n                                });\r\n                                return isValid.pos = pos + l, isValid;\r\n                            }\r\n                            if (!0 === (isValid = strict ? new RegExp(\"[0-9\" + Inputmask.escapeRegex(opts.groupSeparator) + \"]\").test(chrs) : new RegExp(\"[0-9]\").test(chrs))) {\r\n                                if (!0 !== opts.numericInput && maskset.validPositions[pos] !== undefined && \"~\" === maskset.validPositions[pos].match.def && !isSelection) {\r\n                                    var processValue = maskset.buffer.join(\"\"), pvRadixSplit = (processValue = (processValue = processValue.replace(new RegExp(\"[-\" + Inputmask.escapeRegex(opts.negationSymbol.front) + \"]\", \"g\"), \"\")).replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + \"$\"), \"\")).split(opts.radixPoint);\r\n                                    pvRadixSplit.length > 1 && (pvRadixSplit[1] = pvRadixSplit[1].replace(/0/g, opts.placeholder.charAt(0))), \r\n                                    \"0\" === pvRadixSplit[0] && (pvRadixSplit[0] = pvRadixSplit[0].replace(/0/g, opts.placeholder.charAt(0))), \r\n                                    processValue = pvRadixSplit[0] + opts.radixPoint + pvRadixSplit[1] || \"\";\r\n                                    var bufferTemplate = maskset._buffer.join(\"\");\r\n                                    for (processValue === opts.radixPoint && (processValue = bufferTemplate); null === processValue.match(Inputmask.escapeRegex(bufferTemplate) + \"$\"); ) bufferTemplate = bufferTemplate.slice(1);\r\n                                    isValid = (processValue = (processValue = processValue.replace(bufferTemplate, \"\")).split(\"\"))[pos] === undefined ? {\r\n                                        pos: pos,\r\n                                        remove: pos\r\n                                    } : {\r\n                                        pos: pos\r\n                                    };\r\n                                }\r\n                            } else strict || chrs !== opts.radixPoint || maskset.validPositions[pos - 1] !== undefined || (isValid = {\r\n                                insert: {\r\n                                    pos: pos,\r\n                                    c: 0\r\n                                },\r\n                                pos: pos + 1\r\n                            });\r\n                            return isValid;\r\n                        },\r\n                        cardinality: 1\r\n                    },\r\n                    \"+\": {\r\n                        validator: function(chrs, maskset, pos, strict, opts) {\r\n                            return opts.allowMinus && (\"-\" === chrs || chrs === opts.negationSymbol.front);\r\n                        },\r\n                        cardinality: 1,\r\n                        placeholder: \"\"\r\n                    },\r\n                    \"-\": {\r\n                        validator: function(chrs, maskset, pos, strict, opts) {\r\n                            return opts.allowMinus && chrs === opts.negationSymbol.back;\r\n                        },\r\n                        cardinality: 1,\r\n                        placeholder: \"\"\r\n                    },\r\n                    \":\": {\r\n                        validator: function(chrs, maskset, pos, strict, opts) {\r\n                            var radix = \"[\" + Inputmask.escapeRegex(opts.radixPoint) + \"]\", isValid = new RegExp(radix).test(chrs);\r\n                            return isValid && maskset.validPositions[pos] && maskset.validPositions[pos].match.placeholder === opts.radixPoint && (isValid = {\r\n                                caret: pos + 1\r\n                            }), isValid;\r\n                        },\r\n                        cardinality: 1,\r\n                        placeholder: function(opts) {\r\n                            return opts.radixPoint;\r\n                        }\r\n                    }\r\n                },\r\n                onUnMask: function(maskedValue, unmaskedValue, opts) {\r\n                    if (\"\" === unmaskedValue && !0 === opts.nullable) return unmaskedValue;\r\n                    var processValue = maskedValue.replace(opts.prefix, \"\");\r\n                    return processValue = (processValue = processValue.replace(opts.suffix, \"\")).replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\"), \r\n                    \"\" !== opts.placeholder.charAt(0) && (processValue = processValue.replace(new RegExp(opts.placeholder.charAt(0), \"g\"), \"0\")), \r\n                    opts.unmaskAsNumber ? (\"\" !== opts.radixPoint && -1 !== processValue.indexOf(opts.radixPoint) && (processValue = processValue.replace(Inputmask.escapeRegex.call(this, opts.radixPoint), \".\")), \r\n                    processValue = (processValue = processValue.replace(new RegExp(\"^\" + Inputmask.escapeRegex(opts.negationSymbol.front)), \"-\")).replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + \"$\"), \"\"), \r\n                    Number(processValue)) : processValue;\r\n                },\r\n                isComplete: function(buffer, opts) {\r\n                    var maskedValue = (opts.numericInput ? buffer.slice().reverse() : buffer).join(\"\");\r\n                    return maskedValue = (maskedValue = (maskedValue = (maskedValue = (maskedValue = maskedValue.replace(new RegExp(\"^\" + Inputmask.escapeRegex(opts.negationSymbol.front)), \"-\")).replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + \"$\"), \"\")).replace(opts.prefix, \"\")).replace(opts.suffix, \"\")).replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator) + \"([0-9]{3})\", \"g\"), \"$1\"), \r\n                    \",\" === opts.radixPoint && (maskedValue = maskedValue.replace(Inputmask.escapeRegex(opts.radixPoint), \".\")), \r\n                    isFinite(maskedValue);\r\n                },\r\n                onBeforeMask: function(initialValue, opts) {\r\n                    if (opts.isNegative = undefined, \"number\" == typeof initialValue && \"\" !== opts.radixPoint && (initialValue = initialValue.toString().replace(\".\", opts.radixPoint)), \r\n                    initialValue = initialValue.toString().charAt(initialValue.length - 1) === opts.radixPoint ? initialValue.toString().substr(0, initialValue.length - 1) : initialValue.toString(), \r\n                    \"\" !== opts.radixPoint && isFinite(initialValue)) {\r\n                        var vs = initialValue.split(\".\"), groupSize = \"\" !== opts.groupSeparator ? parseInt(opts.groupSize) : 0;\r\n                        2 === vs.length && (vs[0].length > groupSize || vs[1].length > groupSize || vs[0].length <= groupSize && vs[1].length < groupSize) && (initialValue = initialValue.replace(\".\", opts.radixPoint));\r\n                    }\r\n                    var kommaMatches = initialValue.match(/,/g), dotMatches = initialValue.match(/\\./g);\r\n                    if (initialValue = dotMatches && kommaMatches ? dotMatches.length > kommaMatches.length ? (initialValue = initialValue.replace(/\\./g, \"\")).replace(\",\", opts.radixPoint) : kommaMatches.length > dotMatches.length ? (initialValue = initialValue.replace(/,/g, \"\")).replace(\".\", opts.radixPoint) : initialValue.indexOf(\".\") < initialValue.indexOf(\",\") ? initialValue.replace(/\\./g, \"\") : initialValue.replace(/,/g, \"\") : initialValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\"), \r\n                    0 === opts.digits && (-1 !== initialValue.indexOf(\".\") ? initialValue = initialValue.substring(0, initialValue.indexOf(\".\")) : -1 !== initialValue.indexOf(\",\") && (initialValue = initialValue.substring(0, initialValue.indexOf(\",\")))), \r\n                    \"\" !== opts.radixPoint && isFinite(opts.digits) && -1 !== initialValue.indexOf(opts.radixPoint)) {\r\n                        var decPart = initialValue.split(opts.radixPoint)[1].match(new RegExp(\"\\\\d*\"))[0];\r\n                        if (parseInt(opts.digits) < decPart.toString().length) {\r\n                            var digitsFactor = Math.pow(10, parseInt(opts.digits));\r\n                            initialValue = initialValue.replace(Inputmask.escapeRegex(opts.radixPoint), \".\"), \r\n                            initialValue = (initialValue = Math.round(parseFloat(initialValue) * digitsFactor) / digitsFactor).toString().replace(\".\", opts.radixPoint);\r\n                        }\r\n                    }\r\n                    return function(buffer, opts) {\r\n                        if (opts.numericInput) {\r\n                            var radixPosition = $.inArray(opts.radixPoint, buffer);\r\n                            -1 === radixPosition && (buffer.push(opts.radixPoint), radixPosition = buffer.length - 1);\r\n                            for (var i = 1; i <= opts.digits; i++) buffer[radixPosition + i] = buffer[radixPosition + i] || \"0\";\r\n                        }\r\n                        return buffer;\r\n                    }(initialValue.toString().split(\"\"), opts).join(\"\");\r\n                },\r\n                onKeyDown: function(e, buffer, caretPos, opts) {\r\n                    var $input = $(this);\r\n                    if (e.ctrlKey) switch (e.keyCode) {\r\n                      case Inputmask.keyCode.UP:\r\n                        $input.val(parseFloat(this.inputmask.unmaskedvalue()) + parseInt(opts.step)), $input.trigger(\"setvalue\");\r\n                        break;\r\n\r\n                      case Inputmask.keyCode.DOWN:\r\n                        $input.val(parseFloat(this.inputmask.unmaskedvalue()) - parseInt(opts.step)), $input.trigger(\"setvalue\");\r\n                    }\r\n                }\r\n            },\r\n            currency: {\r\n                prefix: \"$ \",\r\n                groupSeparator: \",\",\r\n                alias: \"numeric\",\r\n                placeholder: \"0\",\r\n                autoGroup: !0,\r\n                digits: 2,\r\n                digitsOptional: !1,\r\n                clearMaskOnLostFocus: !1\r\n            },\r\n            decimal: {\r\n                alias: \"numeric\"\r\n            },\r\n            integer: {\r\n                alias: \"numeric\",\r\n                digits: 0,\r\n                radixPoint: \"\"\r\n            },\r\n            percentage: {\r\n                alias: \"numeric\",\r\n                digits: 2,\r\n                digitsOptional: !0,\r\n                radixPoint: \".\",\r\n                placeholder: \"0\",\r\n                autoGroup: !1,\r\n                min: 0,\r\n                max: 100,\r\n                suffix: \" %\",\r\n                allowMinus: !1\r\n            }\r\n        }), Inputmask;\r\n    }) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);\r\n}, function(module, exports, __webpack_require__) {\r\n    \"use strict\";\r\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\r\n    \"function\" == typeof Symbol && Symbol.iterator;\r\n    __WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(2), __webpack_require__(4) ], \r\n    void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = \"function\" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = function($, Inputmask) {\r\n        function maskSort(a, b) {\r\n            var maska = (a.mask || a).replace(/#/g, \"0\").replace(/\\)/, \"0\").replace(/[+()#-]/g, \"\"), maskb = (b.mask || b).replace(/#/g, \"0\").replace(/\\)/, \"0\").replace(/[+()#-]/g, \"\");\r\n            return maska.localeCompare(maskb);\r\n        }\r\n        var analyseMaskBase = Inputmask.prototype.analyseMask;\r\n        return Inputmask.prototype.analyseMask = function(mask, regexMask, opts) {\r\n            var maskGroups = {};\r\n            return opts.phoneCodes && (opts.phoneCodes && opts.phoneCodes.length > 1e3 && (function reduceVariations(masks, previousVariation, previousmaskGroup) {\r\n                previousVariation = previousVariation || \"\", previousmaskGroup = previousmaskGroup || maskGroups, \r\n                \"\" !== previousVariation && (previousmaskGroup[previousVariation] = {});\r\n                for (var variation = \"\", maskGroup = previousmaskGroup[previousVariation] || previousmaskGroup, i = masks.length - 1; i >= 0; i--) maskGroup[variation = (mask = masks[i].mask || masks[i]).substr(0, 1)] = maskGroup[variation] || [], \r\n                maskGroup[variation].unshift(mask.substr(1)), masks.splice(i, 1);\r\n                for (var ndx in maskGroup) maskGroup[ndx].length > 500 && reduceVariations(maskGroup[ndx].slice(), ndx, maskGroup);\r\n            }((mask = mask.substr(1, mask.length - 2)).split(opts.groupmarker[1] + opts.alternatormarker + opts.groupmarker[0])), \r\n            mask = function rebuild(maskGroup) {\r\n                var mask = \"\", submasks = [];\r\n                for (var ndx in maskGroup) $.isArray(maskGroup[ndx]) ? 1 === maskGroup[ndx].length ? submasks.push(ndx + maskGroup[ndx]) : submasks.push(ndx + opts.groupmarker[0] + maskGroup[ndx].join(opts.groupmarker[1] + opts.alternatormarker + opts.groupmarker[0]) + opts.groupmarker[1]) : submasks.push(ndx + rebuild(maskGroup[ndx]));\r\n                return 1 === submasks.length ? mask += submasks[0] : mask += opts.groupmarker[0] + submasks.join(opts.groupmarker[1] + opts.alternatormarker + opts.groupmarker[0]) + opts.groupmarker[1], \r\n                mask;\r\n            }(maskGroups)), mask = mask.replace(/9/g, \"\\\\9\")), analyseMaskBase.call(this, mask, regexMask, opts);\r\n        }, Inputmask.extendAliases({\r\n            abstractphone: {\r\n                groupmarker: [ \"<\", \">\" ],\r\n                countrycode: \"\",\r\n                phoneCodes: [],\r\n                keepStatic: \"auto\",\r\n                mask: function(opts) {\r\n                    return opts.definitions = {\r\n                        \"#\": Inputmask.prototype.definitions[9]\r\n                    }, opts.phoneCodes.sort(maskSort);\r\n                },\r\n                onBeforeMask: function(value, opts) {\r\n                    var processedValue = value.replace(/^0{1,2}/, \"\").replace(/[\\s]/g, \"\");\r\n                    return (processedValue.indexOf(opts.countrycode) > 1 || -1 === processedValue.indexOf(opts.countrycode)) && (processedValue = \"+\" + opts.countrycode + processedValue), \r\n                    processedValue;\r\n                },\r\n                onUnMask: function(maskedValue, unmaskedValue, opts) {\r\n                    return maskedValue.replace(/[()#-]/g, \"\");\r\n                },\r\n                inputmode: \"tel\"\r\n            }\r\n        }), Inputmask;\r\n    }) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);\r\n}, function(module, exports, __webpack_require__) {\r\n    \"use strict\";\r\n    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__, _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\r\n        return typeof obj;\r\n    } : function(obj) {\r\n        return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\r\n    };\r\n    __WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(3), __webpack_require__(4) ], \r\n    void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = \"function\" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = function($, Inputmask) {\r\n        return void 0 === $.fn.inputmask && ($.fn.inputmask = function(fn, options) {\r\n            var nptmask, input = this[0];\r\n            if (void 0 === options && (options = {}), \"string\" == typeof fn) switch (fn) {\r\n              case \"unmaskedvalue\":\r\n                return input && input.inputmask ? input.inputmask.unmaskedvalue() : $(input).val();\r\n\r\n              case \"remove\":\r\n                return this.each(function() {\r\n                    this.inputmask && this.inputmask.remove();\r\n                });\r\n\r\n              case \"getemptymask\":\r\n                return input && input.inputmask ? input.inputmask.getemptymask() : \"\";\r\n\r\n              case \"hasMaskedValue\":\r\n                return !(!input || !input.inputmask) && input.inputmask.hasMaskedValue();\r\n\r\n              case \"isComplete\":\r\n                return !input || !input.inputmask || input.inputmask.isComplete();\r\n\r\n              case \"getmetadata\":\r\n                return input && input.inputmask ? input.inputmask.getmetadata() : void 0;\r\n\r\n              case \"setvalue\":\r\n                Inputmask.setValue(input, options);\r\n                break;\r\n\r\n              case \"option\":\r\n                if (\"string\" != typeof options) return this.each(function() {\r\n                    if (void 0 !== this.inputmask) return this.inputmask.option(options);\r\n                });\r\n                if (input && void 0 !== input.inputmask) return input.inputmask.option(options);\r\n                break;\r\n\r\n              default:\r\n                return options.alias = fn, nptmask = new Inputmask(options), this.each(function() {\r\n                    nptmask.mask(this);\r\n                });\r\n            } else {\r\n                if (\"object\" == (void 0 === fn ? \"undefined\" : _typeof(fn))) return nptmask = new Inputmask(fn), \r\n                void 0 === fn.mask && void 0 === fn.alias ? this.each(function() {\r\n                    if (void 0 !== this.inputmask) return this.inputmask.option(fn);\r\n                    nptmask.mask(this);\r\n                }) : this.each(function() {\r\n                    nptmask.mask(this);\r\n                });\r\n                if (void 0 === fn) return this.each(function() {\r\n                    (nptmask = new Inputmask(options)).mask(this);\r\n                });\r\n            }\r\n        }), $.fn.inputmask;\r\n    }) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);\r\n} ]);\r\n","\r\n/*\r\n* jquery-match-height 0.7.2 by @liabru\r\n* http://brm.io/jquery-match-height/\r\n* License MIT\r\n*/\r\n!function (t) { \"use strict\"; \"function\" == typeof define && define.amd ? define([\"jquery\"], t) : \"undefined\" != typeof module && module.exports ? module.exports = t(require(\"jquery\")) : t(jQuery) }(function (t) {\r\n\tvar e = -1, o = -1, n = function (t) { return parseFloat(t) || 0 }, a = function (e) { var o = 1, a = t(e), i = null, r = []; return a.each(function () { var e = t(this), a = e.offset().top - n(e.css(\"margin-top\")), s = r.length > 0 ? r[r.length - 1] : null; null === s ? r.push(e) : Math.floor(Math.abs(i - a)) <= o ? r[r.length - 1] = s.add(e) : r.push(e), i = a }), r }, i = function (e) {\r\n\t\tvar o = {\r\n\t\t\tbyRow: !0, property: \"height\", target: null, remove: !1\r\n\t\t}; return \"object\" == typeof e ? t.extend(o, e) : (\"boolean\" == typeof e ? o.byRow = e : \"remove\" === e && (o.remove = !0), o)\r\n\t}, r = t.fn.matchHeight = function (e) { var o = i(e); if (o.remove) { var n = this; return this.css(o.property, \"\"), t.each(r._groups, function (t, e) { e.elements = e.elements.not(n) }), this } return this.length <= 1 && !o.target ? this : (r._groups.push({ elements: this, options: o }), r._apply(this, o), this) }; r.version = \"0.7.2\", r._groups = [], r._throttle = 80, r._maintainScroll = !1, r._beforeUpdate = null,\r\n\t\tr._afterUpdate = null, r._rows = a, r._parse = n, r._parseOptions = i, r._apply = function (e, o) {\r\n\t\t\tvar s = i(o), h = t(e), l = [h], c = t(window).scrollTop(), p = t(\"html\").outerHeight(!0), u = h.parents().filter(\":hidden\"); return u.each(function () { var e = t(this); e.data(\"style-cache\", e.attr(\"style\")) }), u.css(\"display\", \"block\"), s.byRow && !s.target && (h.each(function () {\r\n\t\t\t\tvar e = t(this), o = e.css(\"display\"); \"inline-block\" !== o && \"flex\" !== o && \"inline-flex\" !== o && (o = \"block\"), e.data(\"style-cache\", e.attr(\"style\")), e.css({\r\n\t\t\t\t\tdisplay: o, \"padding-top\": \"0\",\r\n\t\t\t\t\t\"padding-bottom\": \"0\", \"margin-top\": \"0\", \"margin-bottom\": \"0\", \"border-top-width\": \"0\", \"border-bottom-width\": \"0\", height: \"100px\", overflow: \"hidden\"\r\n\t\t\t\t})\r\n\t\t\t}), l = a(h), h.each(function () { var e = t(this); e.attr(\"style\", e.data(\"style-cache\") || \"\") })), t.each(l, function (e, o) {\r\n\t\t\t\tvar a = t(o), i = 0; if (s.target) i = s.target.outerHeight(!1); else {\r\n\t\t\t\t\tif (s.byRow && a.length <= 1) return void a.css(s.property, \"\"); a.each(function () {\r\n\t\t\t\t\t\tvar e = t(this), o = e.attr(\"style\"), n = e.css(\"display\"); \"inline-block\" !== n && \"flex\" !== n && \"inline-flex\" !== n && (n = \"block\"); var a = {\r\n\t\t\t\t\t\t\tdisplay: n\r\n\t\t\t\t\t\t}; a[s.property] = \"\", e.css(a), e.outerHeight(!1) > i && (i = e.outerHeight(!1)), o ? e.attr(\"style\", o) : e.css(\"display\", \"\")\r\n\t\t\t\t\t})\r\n\t\t\t\t} a.each(function () { var e = t(this), o = 0; s.target && e.is(s.target) || (\"border-box\" !== e.css(\"box-sizing\") && (o += n(e.css(\"border-top-width\")) + n(e.css(\"border-bottom-width\")), o += n(e.css(\"padding-top\")) + n(e.css(\"padding-bottom\"))), e.css(s.property, i - o + \"px\")) })\r\n\t\t\t}), u.each(function () { var e = t(this); e.attr(\"style\", e.data(\"style-cache\") || null) }), r._maintainScroll && t(window).scrollTop(c / p * t(\"html\").outerHeight(!0)),\r\n\t\t\t\tthis\r\n\t\t}, r._applyDataApi = function () { var e = {}; t(\"[data-match-height], [data-mh]\").each(function () { var o = t(this), n = o.attr(\"data-mh\") || o.attr(\"data-match-height\"); n in e ? e[n] = e[n].add(o) : e[n] = o }), t.each(e, function () { this.matchHeight(!0) }) }; var s = function (e) { r._beforeUpdate && r._beforeUpdate(e, r._groups), t.each(r._groups, function () { r._apply(this.elements, this.options) }), r._afterUpdate && r._afterUpdate(e, r._groups) }; r._update = function (n, a) {\r\n\t\t\tif (a && \"resize\" === a.type) {\r\n\t\t\t\tvar i = t(window).width(); if (i === e) return; e = i;\r\n\t\t\t} n ? o === -1 && (o = setTimeout(function () { s(a), o = -1 }, r._throttle)) : s(a)\r\n\t\t}, t(r._applyDataApi); var h = t.fn.on ? \"on\" : \"bind\"; t(window)[h](\"load\", function (t) { r._update(!1, t) }), t(window)[h](\"resize orientationchange\", function (t) { r._update(!0, t) })\r\n});","\r\n/*! lazysizes - v4.0.1 */\r\n!function(a,b){var c=b(a,a.document);a.lazySizes=c,\"object\"==typeof module&&module.exports&&(module.exports=c)}(window,function(a,b){\"use strict\";if(b.getElementsByClassName){var c,d,e=b.documentElement,f=a.Date,g=a.HTMLPictureElement,h=\"addEventListener\",i=\"getAttribute\",j=a[h],k=a.setTimeout,l=a.requestAnimationFrame||k,m=a.requestIdleCallback,n=/^picture$/i,o=[\"load\",\"error\",\"lazyincluded\",\"_lazyloaded\"],p={},q=Array.prototype.forEach,r=function(a,b){return p[b]||(p[b]=new RegExp(\"(\\\\s|^)\"+b+\"(\\\\s|$)\")),p[b].test(a[i](\"class\")||\"\")&&p[b]},s=function(a,b){r(a,b)||a.setAttribute(\"class\",(a[i](\"class\")||\"\").trim()+\" \"+b)},t=function(a,b){var c;(c=r(a,b))&&a.setAttribute(\"class\",(a[i](\"class\")||\"\").replace(c,\" \"))},u=function(a,b,c){var d=c?h:\"removeEventListener\";c&&u(a,b),o.forEach(function(c){a[d](c,b)})},v=function(a,d,e,f,g){var h=b.createEvent(\"CustomEvent\");return e||(e={}),e.instance=c,h.initCustomEvent(d,!f,!g,e),a.dispatchEvent(h),h},w=function(b,c){var e;!g&&(e=a.picturefill||d.pf)?e({reevaluate:!0,elements:[b]}):c&&c.src&&(b.src=c.src)},x=function(a,b){return(getComputedStyle(a,null)||{})[b]},y=function(a,b,c){for(c=c||a.offsetWidth;c<d.minSize&&b&&!a._lazysizesWidth;)c=b.offsetWidth,b=b.parentNode;return c},z=function(){var a,c,d=[],e=[],f=d,g=function(){var b=f;for(f=d.length?e:d,a=!0,c=!1;b.length;)b.shift()();a=!1},h=function(d,e){a&&!e?d.apply(this,arguments):(f.push(d),c||(c=!0,(b.hidden?k:l)(g)))};return h._lsFlush=g,h}(),A=function(a,b){return b?function(){z(a)}:function(){var b=this,c=arguments;z(function(){a.apply(b,c)})}},B=function(a){var b,c=0,e=125,g=d.ricTimeout,h=function(){b=!1,c=f.now(),a()},i=m&&d.ricTimeout?function(){m(h,{timeout:g}),g!==d.ricTimeout&&(g=d.ricTimeout)}:A(function(){k(h)},!0);return function(a){var d;(a=a===!0)&&(g=33),b||(b=!0,d=e-(f.now()-c),0>d&&(d=0),a||9>d&&m?i():k(i,d))}},C=function(a){var b,c,d=99,e=function(){b=null,a()},g=function(){var a=f.now()-c;d>a?k(g,d-a):(m||e)(e)};return function(){c=f.now(),b||(b=k(g,d))}};!function(){var b,c={lazyClass:\"lazyload\",loadedClass:\"lazyloaded\",loadingClass:\"lazyloading\",preloadClass:\"lazypreload\",errorClass:\"lazyerror\",autosizesClass:\"lazyautosizes\",srcAttr:\"data-src\",srcsetAttr:\"data-srcset\",sizesAttr:\"data-sizes\",minSize:40,customMedia:{},init:!0,expFactor:1.5,hFac:.8,loadMode:2,loadHidden:!0,ricTimeout:300};d=a.lazySizesConfig||a.lazysizesConfig||{};for(b in c)b in d||(d[b]=c[b]);a.lazySizesConfig=d,k(function(){d.init&&F()})}();var D=function(){var g,l,m,o,p,y,D,F,G,H,I,J,K,L,M=/^img$/i,N=/^iframe$/i,O=\"onscroll\"in a&&!/glebot/.test(navigator.userAgent),P=0,Q=0,R=0,S=-1,T=function(a){R--,a&&a.target&&u(a.target,T),(!a||0>R||!a.target)&&(R=0)},U=function(a,c){var d,f=a,g=\"hidden\"==x(b.body,\"visibility\")||\"hidden\"!=x(a,\"visibility\");for(F-=c,I+=c,G-=c,H+=c;g&&(f=f.offsetParent)&&f!=b.body&&f!=e;)g=(x(f,\"opacity\")||1)>0,g&&\"visible\"!=x(f,\"overflow\")&&(d=f.getBoundingClientRect(),g=H>d.left&&G<d.right&&I>d.top-1&&F<d.bottom+1);return g},V=function(){var a,f,h,j,k,m,n,p,q,r=c.elements;if((o=d.loadMode)&&8>R&&(a=r.length)){f=0,S++,null==K&&(\"expand\"in d||(d.expand=e.clientHeight>500&&e.clientWidth>500?500:370),J=d.expand,K=J*d.expFactor),K>Q&&1>R&&S>2&&o>2&&!b.hidden?(Q=K,S=0):Q=o>1&&S>1&&6>R?J:P;for(;a>f;f++)if(r[f]&&!r[f]._lazyRace)if(O)if((p=r[f][i](\"data-expand\"))&&(m=1*p)||(m=Q),q!==m&&(y=innerWidth+m*L,D=innerHeight+m,n=-1*m,q=m),h=r[f].getBoundingClientRect(),(I=h.bottom)>=n&&(F=h.top)<=D&&(H=h.right)>=n*L&&(G=h.left)<=y&&(I||H||G||F)&&(d.loadHidden||\"hidden\"!=x(r[f],\"visibility\"))&&(l&&3>R&&!p&&(3>o||4>S)||U(r[f],m))){if(ba(r[f]),k=!0,R>9)break}else!k&&l&&!j&&4>R&&4>S&&o>2&&(g[0]||d.preloadAfterLoad)&&(g[0]||!p&&(I||H||G||F||\"auto\"!=r[f][i](d.sizesAttr)))&&(j=g[0]||r[f]);else ba(r[f]);j&&!k&&ba(j)}},W=B(V),X=function(a){s(a.target,d.loadedClass),t(a.target,d.loadingClass),u(a.target,Z),v(a.target,\"lazyloaded\")},Y=A(X),Z=function(a){Y({target:a.target})},$=function(a,b){try{a.contentWindow.location.replace(b)}catch(c){a.src=b}},_=function(a){var b,c=a[i](d.srcsetAttr);(b=d.customMedia[a[i](\"data-media\")||a[i](\"media\")])&&a.setAttribute(\"media\",b),c&&a.setAttribute(\"srcset\",c)},aa=A(function(a,b,c,e,f){var g,h,j,l,o,p;(o=v(a,\"lazybeforeunveil\",b)).defaultPrevented||(e&&(c?s(a,d.autosizesClass):a.setAttribute(\"sizes\",e)),h=a[i](d.srcsetAttr),g=a[i](d.srcAttr),f&&(j=a.parentNode,l=j&&n.test(j.nodeName||\"\")),p=b.firesLoad||\"src\"in a&&(h||g||l),o={target:a},p&&(u(a,T,!0),clearTimeout(m),m=k(T,2500),s(a,d.loadingClass),u(a,Z,!0)),l&&q.call(j.getElementsByTagName(\"source\"),_),h?a.setAttribute(\"srcset\",h):g&&!l&&(N.test(a.nodeName)?$(a,g):a.src=g),f&&(h||l)&&w(a,{src:g})),a._lazyRace&&delete a._lazyRace,t(a,d.lazyClass),z(function(){(!p||a.complete&&a.naturalWidth>1)&&(p?T(o):R--,X(o))},!0)}),ba=function(a){var b,c=M.test(a.nodeName),e=c&&(a[i](d.sizesAttr)||a[i](\"sizes\")),f=\"auto\"==e;(!f&&l||!c||!a[i](\"src\")&&!a.srcset||a.complete||r(a,d.errorClass)||!r(a,d.lazyClass))&&(b=v(a,\"lazyunveilread\").detail,f&&E.updateElem(a,!0,a.offsetWidth),a._lazyRace=!0,R++,aa(a,b,f,e,c))},ca=function(){if(!l){if(f.now()-p<999)return void k(ca,999);var a=C(function(){d.loadMode=3,W()});l=!0,d.loadMode=3,W(),j(\"scroll\",function(){3==d.loadMode&&(d.loadMode=2),a()},!0)}};return{_:function(){p=f.now(),c.elements=b.getElementsByClassName(d.lazyClass),g=b.getElementsByClassName(d.lazyClass+\" \"+d.preloadClass),L=d.hFac,j(\"scroll\",W,!0),j(\"resize\",W,!0),a.MutationObserver?new MutationObserver(W).observe(e,{childList:!0,subtree:!0,attributes:!0}):(e[h](\"DOMNodeInserted\",W,!0),e[h](\"DOMAttrModified\",W,!0),setInterval(W,999)),j(\"hashchange\",W,!0),[\"focus\",\"mouseover\",\"click\",\"load\",\"transitionend\",\"animationend\",\"webkitAnimationEnd\"].forEach(function(a){b[h](a,W,!0)}),/d$|^c/.test(b.readyState)?ca():(j(\"load\",ca),b[h](\"DOMContentLoaded\",W),k(ca,2e4)),c.elements.length?(V(),z._lsFlush()):W()},checkElems:W,unveil:ba}}(),E=function(){var a,c=A(function(a,b,c,d){var e,f,g;if(a._lazysizesWidth=d,d+=\"px\",a.setAttribute(\"sizes\",d),n.test(b.nodeName||\"\"))for(e=b.getElementsByTagName(\"source\"),f=0,g=e.length;g>f;f++)e[f].setAttribute(\"sizes\",d);c.detail.dataAttr||w(a,c.detail)}),e=function(a,b,d){var e,f=a.parentNode;f&&(d=y(a,f,d),e=v(a,\"lazybeforesizes\",{width:d,dataAttr:!!b}),e.defaultPrevented||(d=e.detail.width,d&&d!==a._lazysizesWidth&&c(a,f,e,d)))},f=function(){var b,c=a.length;if(c)for(b=0;c>b;b++)e(a[b])},g=C(f);return{_:function(){a=b.getElementsByClassName(d.autosizesClass),j(\"resize\",g)},checkElems:g,updateElem:e}}(),F=function(){F.i||(F.i=!0,E._(),D._())};return c={cfg:d,autoSizer:E,loader:D,init:F,uP:w,aC:s,rC:t,hC:r,fire:v,gW:y,rAF:z}}});","\r\n!function (t) { if (\"object\" == typeof exports && \"undefined\" != typeof module) module.exports = t(); else if (\"function\" == typeof define && define.amd) define([], t); else { var e; \"undefined\" != typeof window ? e = window : \"undefined\" != typeof global ? e = global : \"undefined\" != typeof self && (e = self), e.Slideout = t() } }(function () { var t, e, n; return function i(t, e, n) { function o(r, a) { if (!e[r]) { if (!t[r]) { var u = typeof require == \"function\" && require; if (!a && u) return u(r, !0); if (s) return s(r, !0); var l = new Error(\"Cannot find module '\" + r + \"'\"); throw l.code = \"MODULE_NOT_FOUND\", l } var h = e[r] = { exports: {} }; t[r][0].call(h.exports, function (e) { var n = t[r][1][e]; return o(n ? n : e) }, h, h.exports, i, t, e, n) } return e[r].exports } var s = typeof require == \"function\" && require; for (var r = 0; r < n.length; r++)o(n[r]); return o }({ 1: [function (t, e, n) { \"use strict\"; var i = t(\"decouple\"); var o = t(\"emitter\"); var s; var r = false; var a = window.document; var u = a.documentElement; var l = window.navigator.msPointerEnabled; var h = { start: l ? \"MSPointerDown\" : \"touchstart\", move: l ? \"MSPointerMove\" : \"touchmove\", end: l ? \"MSPointerUp\" : \"touchend\" }; var f = function v() { var t = /^(Webkit|Khtml|Moz|ms|O)(?=[A-Z])/; var e = a.getElementsByTagName(\"script\")[0].style; for (var n in e) { if (t.test(n)) { return \"-\" + n.match(t)[0].toLowerCase() + \"-\" } } if (\"WebkitOpacity\" in e) { return \"-webkit-\" } if (\"KhtmlOpacity\" in e) { return \"-khtml-\" } return \"\" }(); function c(t, e) { for (var n in e) { if (e[n]) { t[n] = e[n] } } return t } function p(t, e) { t.prototype = c(t.prototype || {}, e.prototype) } function d(t) { while (t.parentNode) { if (t.getAttribute(\"data-slideout-ignore\") !== null) { return t } t = t.parentNode } return null } function _(t) { t = t || {}; this._startOffsetX = 0; this._currentOffsetX = 0; this._opening = false; this._moved = false; this._opened = false; this._preventOpen = false; this.panel = t.panel; this.menu = t.menu; this._touch = t.touch === undefined ? true : t.touch && true; this._side = t.side || \"left\"; this._easing = t.fx || t.easing || \"ease\"; this._duration = parseInt(t.duration, 10) || 300; this._tolerance = parseInt(t.tolerance, 10) || 70; this._padding = this._translateTo = parseInt(t.padding, 10) || 256; this._orientation = this._side === \"right\" ? -1 : 1; this._translateTo *= this._orientation; if (!this.panel.classList.contains(\"slideout-panel\")) { this.panel.classList.add(\"slideout-panel\") } if (!this.panel.classList.contains(\"slideout-panel-\" + this._side)) { this.panel.classList.add(\"slideout-panel-\" + this._side) } if (!this.menu.classList.contains(\"slideout-menu\")) { this.menu.classList.add(\"slideout-menu\") } if (!this.menu.classList.contains(\"slideout-menu-\" + this._side)) { this.menu.classList.add(\"slideout-menu-\" + this._side) } if (this._touch) { this._initTouchEvents() } } p(_, o); _.prototype.open = function () { var t = this; this.emit(\"beforeopen\"); if (!u.classList.contains(\"slideout-open\")) { u.classList.add(\"slideout-open\") } this._setTransition(); this._translateXTo(this._translateTo); this._opened = true; setTimeout(function () { t.panel.style.transition = t.panel.style[\"-webkit-transition\"] = \"\"; t.emit(\"open\") }, this._duration + 50); return this }; _.prototype.close = function () { var t = this; if (!this.isOpen() && !this._opening) { return this } this.emit(\"beforeclose\"); this._setTransition(); this._translateXTo(0); this._opened = false; setTimeout(function () { u.classList.remove(\"slideout-open\"); t.panel.style.transition = t.panel.style[\"-webkit-transition\"] = t.panel.style[f + \"transform\"] = t.panel.style.transform = \"\"; t.emit(\"close\") }, this._duration + 50); return this }; _.prototype.toggle = function () { return this.isOpen() ? this.close() : this.open() }; _.prototype.isOpen = function () { return this._opened }; _.prototype._translateXTo = function (t) { this._currentOffsetX = t; this.panel.style[f + \"transform\"] = this.panel.style.transform = \"translateX(\" + t + \"px)\"; return this }; _.prototype._setTransition = function () { this.panel.style[f + \"transition\"] = this.panel.style.transition = f + \"transform \" + this._duration + \"ms \" + this._easing; return this }; _.prototype._initTouchEvents = function () { var t = this; this._onScrollFn = i(a, \"scroll\", function () { if (!t._moved) { clearTimeout(s); r = true; s = setTimeout(function () { r = false }, 250) } }); this._preventMove = function (e) { if (t._moved) { e.preventDefault() } }; a.addEventListener(h.move, this._preventMove); this._resetTouchFn = function (e) { if (typeof e.touches === \"undefined\") { return } t._moved = false; t._opening = false; t._startOffsetX = e.touches[0].pageX; t._preventOpen = !t._touch || !t.isOpen() && t.menu.clientWidth !== 0 }; this.panel.addEventListener(h.start, this._resetTouchFn); this._onTouchCancelFn = function () { t._moved = false; t._opening = false }; this.panel.addEventListener(\"touchcancel\", this._onTouchCancelFn); this._onTouchEndFn = function () { if (t._moved) { t.emit(\"translateend\"); t._opening && Math.abs(t._currentOffsetX) > t._tolerance ? t.open() : t.close() } t._moved = false }; this.panel.addEventListener(h.end, this._onTouchEndFn); this._onTouchMoveFn = function (e) { if (r || t._preventOpen || typeof e.touches === \"undefined\" || d(e.target)) { return } var n = e.touches[0].clientX - t._startOffsetX; var i = t._currentOffsetX = n; if (Math.abs(i) > t._padding) { return } if (Math.abs(n) > 20) { t._opening = true; var o = n * t._orientation; if (t._opened && o > 0 || !t._opened && o < 0) { return } if (!t._moved) { t.emit(\"translatestart\") } if (o <= 0) { i = n + t._padding * t._orientation; t._opening = false } if (!(t._moved && u.classList.contains(\"slideout-open\"))) { u.classList.add(\"slideout-open\") } t.panel.style[f + \"transform\"] = t.panel.style.transform = \"translateX(\" + i + \"px)\"; t.emit(\"translate\", i); t._moved = true } }; this.panel.addEventListener(h.move, this._onTouchMoveFn); return this }; _.prototype.enableTouch = function () { this._touch = true; return this }; _.prototype.disableTouch = function () { this._touch = false; return this }; _.prototype.destroy = function () { this.close(); a.removeEventListener(h.move, this._preventMove); this.panel.removeEventListener(h.start, this._resetTouchFn); this.panel.removeEventListener(\"touchcancel\", this._onTouchCancelFn); this.panel.removeEventListener(h.end, this._onTouchEndFn); this.panel.removeEventListener(h.move, this._onTouchMoveFn); a.removeEventListener(\"scroll\", this._onScrollFn); this.open = this.close = function () { }; return this }; e.exports = _ }, { decouple: 2, emitter: 3 }], 2: [function (t, e, n) { \"use strict\"; var i = function () { return window.requestAnimationFrame || window.webkitRequestAnimationFrame || function (t) { window.setTimeout(t, 1e3 / 60) } }(); function o(t, e, n) { var o, s = false; function r(t) { o = t; a() } function a() { if (!s) { i(u); s = true } } function u() { n.call(t, o); s = false } t.addEventListener(e, r, false); return r } e.exports = o }, {}], 3: [function (t, e, n) { \"use strict\"; var i = function (t, e) { if (!(t instanceof e)) { throw new TypeError(\"Cannot call a class as a function\") } }; n.__esModule = true; var o = function () { function t() { i(this, t) } t.prototype.on = function e(t, n) { this._eventCollection = this._eventCollection || {}; this._eventCollection[t] = this._eventCollection[t] || []; this._eventCollection[t].push(n); return this }; t.prototype.once = function n(t, e) { var n = this; function i() { n.off(t, i); e.apply(this, arguments) } i.listener = e; this.on(t, i); return this }; t.prototype.off = function o(t, e) { var n = undefined; if (!this._eventCollection || !(n = this._eventCollection[t])) { return this } n.forEach(function (t, i) { if (t === e || t.listener === e) { n.splice(i, 1) } }); if (n.length === 0) { delete this._eventCollection[t] } return this }; t.prototype.emit = function s(t) { var e = this; for (var n = arguments.length, i = Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++) { i[o - 1] = arguments[o] } var s = undefined; if (!this._eventCollection || !(s = this._eventCollection[t])) { return this } s = s.slice(0); s.forEach(function (t) { return t.apply(e, i) }); return this }; return t }(); n[\"default\"] = o; e.exports = n[\"default\"] }, {}] }, {}, [1])(1) });","!function (t) { function s() { this.tags = {}, this.tags.popup = p(\"popup\" + (o ? \" popup_iphone\" : \"\") + (i ? \" popup_ie10\" : \"\"), document.body), this.tags.popup__overlay = p(\"popup__overlay\", this.tags.popup), this.tags.popup__table = p(\"popup__table\", this.tags.popup), this.tags.popup__cell = p(\"popup__cell\", this.tags.popup__table), this.tags.popup__block = p(\"popup__block\", this.tags.popup__cell), this.tags.popup__close = p(\"popup__close\", this.tags.popup__block), this.tags.popup__change = p(\"popup__change\", this.tags.popup__block), this.eventsTrigger = e ? \"touchend\" : \"mouseup\", this.events(), this.scrollWidth = this.scrollWidthElement(), this.defaults = { clearClose: !0, bodyHidden: !0, addClassNamePopup: \"\", closeOverlay: !0, closeShow: !0, background: \"\", closeButtons: \"\", offsetY: 0, offsetX: 0, coordElement: \"\" } } var e = /Android|iPhone|iPad|iPod|BlackBerry|WPDesktop|IEMobile|Opera Mini/i.test(navigator.userAgent), o = /iPhone|iPad|iPod/i.test(navigator.userAgent), i = -1 !== navigator.appVersion.indexOf(\"MSIE 10\"), p = function (t, s) { var e = document.createElement(\"div\"); return e.className = t, s && s.appendChild(e), e }; s.prototype = { options: function (t) { return this.defaults = this.extend({ clearClose: !0, bodyHidden: !0, addClassNamePopup: \"\", closeOverlay: !0, closeShow: !0, background: \"\", closeButtons: \"\", offsetY: 0, offsetX: 0, coordElement: \"\" }, t), this.defaults.background && (this.tags.popup.style.background = this.defaults.background), this }, extend: function (t, s) { for (var e in s) s.hasOwnProperty(e) && (t[e] = s[e]); return t }, addCloseButtons: function () { var t = this; this.defaults.closeButtons.split(\",\").forEach(function (s, e) { var o = document.querySelectorAll(s.replace(/\\s+/g, \"\")); Array.prototype.forEach.call(o, function (s, e) { s.addEventListener(t.eventsTrigger, function (s) { return s.stopPropagation(), t.close(), !1 }, !1) }) }) }, coordSet: function () { var t = document.querySelector(this.defaults.coordElement); return t && (this.coords = t.getBoundingClientRect(), this.tags.popup__block.style.left = (this.defaults.bodyHidden ? 0 : window.pageXOffset) + this.coords.left + this.defaults.offsetX + \"px\", this.tags.popup__block.style.top = (this.defaults.bodyHidden ? 0 : window.pageYOffset) + this.coords.top + this.defaults.offsetY + \"px\", this.tags.popup__block.style.position = \"absolute\"), this }, coordReset: function () { var t = this; return this.defaults = { clearClose: !0, bodyHidden: !0, addClassNamePopup: \"\", closeOverlay: !0, closeShow: !0, background: \"\", closeButtons: \"\", offsetY: 0, offsetX: 0, coordElement: \"\" }, setTimeout(function () { t.tags.popup.style.background = \"\" }, 500), this.tags.popup__block.style.left = \"\", this.tags.popup__block.style.top = \"\", this.tags.popup__block.style.position = \"\", this }, setBodyStyle: function () { var t = window.innerHeight < document.body.scrollHeight; return this.defaults.bodyHidden && (document.body.classList.add(\"popup__body_hidden\"), t && (document.body.style.paddingRight = this.scrollWidth + \"px\")), this }, clearBodyStyle: function () { return document.body.classList.remove(\"popup__body_hidden\"), document.body.style.paddingRight = \"\", this }, html: function (t, s) { return this.tags.popup__change.innerHTML = \"\", $(this.tags.popup__change).html(t), s && s.call(this.tags.popup, this.defaults, this.eventsTrigger), this }, append: function (t, s) { return $(this.tags.popup__change).html(t), s && s.call(this.tags.popup, this.defaults, this.eventsTrigger), this.defaults.closeButtons && this.addCloseButtons(), this }, clear: function (t) { return (this.defaults.clearClose || t) && (this.tags.popup__change.innerHTML = \"\"), this }, show: function (t) { return this.defaults.closeShow ? this.tags.popup__close.style.display = \"\" : this.tags.popup__close.style.display = \"none\", this.setBodyStyle(), this.defaults.coordElement && this.coordSet(), this.defaults.closeButtons && this.addCloseButtons(), this.defaults.addClassNamePopup && this.tags.popup.classList.add(this.defaults.addClassNamePopup), this.tags.popup.classList.add(\"popup_active\"), t && t.call(this.tags.popup, this.defaults, this.eventsTrigger), this }, close: function (t) { var s = this; return setTimeout(function () { s.tags.popup.classList.remove(\"popup_active\"), s.defaults.addClassNamePopup && s.tags.popup.classList.remove(s.defaults.addClassNamePopup), s.clear(), s.coordReset(), t && t.call(s.tags.popup, s.defaults, s.eventsTrigger), s.clearBodyStyle() }, 50), this }, events: function () { var t = this; this.tags.popup__close.addEventListener(this.eventsTrigger, function (s) { return s.stopPropagation(), t.close(), !1 }, !1), this.tags.popup__overlay.addEventListener(this.eventsTrigger, function (s) { return s.stopPropagation(), t.defaults.closeOverlay && t.close(), !1 }, !1), document.addEventListener(\"keydown\", function (s) { 27 == s.which && t.close() }, !1) }, scrollWidthElement: function () { var t = document.createElement(\"div\"); t.style.overflowY = \"scroll\", t.style.width = \"50px\", t.style.height = \"50px\", t.style.visibility = \"hidden\", document.body.appendChild(t); var s = t.offsetWidth - t.clientWidth; return document.body.removeChild(t), s } }, window.Popup = s }(window);","/* Font Face Observer v2.0.13 - � Bram Stein. License: BSD-3-Clause */(function(){'use strict';var f,g=[];function l(a){g.push(a);1==g.length&&f()}function m(){for(;g.length;)g[0](),g.shift()}f=function(){setTimeout(m)};function n(a){this.a=p;this.b=void 0;this.f=[];var b=this;try{a(function(a){q(b,a)},function(a){r(b,a)})}catch(c){r(b,c)}}var p=2;function t(a){return new n(function(b,c){c(a)})}function u(a){return new n(function(b){b(a)})}function q(a,b){if(a.a==p){if(b==a)throw new TypeError;var c=!1;try{var d=b&&b.then;if(null!=b&&\"object\"==typeof b&&\"function\"==typeof d){d.call(b,function(b){c||q(a,b);c=!0},function(b){c||r(a,b);c=!0});return}}catch(e){c||r(a,e);return}a.a=0;a.b=b;v(a)}}\r\n  function r(a,b){if(a.a==p){if(b==a)throw new TypeError;a.a=1;a.b=b;v(a)}}function v(a){l(function(){if(a.a!=p)for(;a.f.length;){var b=a.f.shift(),c=b[0],d=b[1],e=b[2],b=b[3];try{0==a.a?\"function\"==typeof c?e(c.call(void 0,a.b)):e(a.b):1==a.a&&(\"function\"==typeof d?e(d.call(void 0,a.b)):b(a.b))}catch(h){b(h)}}})}n.prototype.g=function(a){return this.c(void 0,a)};n.prototype.c=function(a,b){var c=this;return new n(function(d,e){c.f.push([a,b,d,e]);v(c)})};\r\n  function w(a){return new n(function(b,c){function d(c){return function(d){h[c]=d;e+=1;e==a.length&&b(h)}}var e=0,h=[];0==a.length&&b(h);for(var k=0;k<a.length;k+=1)u(a[k]).c(d(k),c)})}function x(a){return new n(function(b,c){for(var d=0;d<a.length;d+=1)u(a[d]).c(b,c)})};window.Promise||(window.Promise=n,window.Promise.resolve=u,window.Promise.reject=t,window.Promise.race=x,window.Promise.all=w,window.Promise.prototype.then=n.prototype.c,window.Promise.prototype[\"catch\"]=n.prototype.g);}());\r\n\r\n(function(){function l(a,b){document.addEventListener?a.addEventListener(\"scroll\",b,!1):a.attachEvent(\"scroll\",b)}function m(a){document.body?a():document.addEventListener?document.addEventListener(\"DOMContentLoaded\",function c(){document.removeEventListener(\"DOMContentLoaded\",c);a()}):document.attachEvent(\"onreadystatechange\",function k(){if(\"interactive\"==document.readyState||\"complete\"==document.readyState)document.detachEvent(\"onreadystatechange\",k),a()})};function r(a){this.a=document.createElement(\"div\");this.a.setAttribute(\"aria-hidden\",\"true\");this.a.appendChild(document.createTextNode(a));this.b=document.createElement(\"span\");this.c=document.createElement(\"span\");this.h=document.createElement(\"span\");this.f=document.createElement(\"span\");this.g=-1;this.b.style.cssText=\"max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;\";this.c.style.cssText=\"max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;\";\r\n  this.f.style.cssText=\"max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;\";this.h.style.cssText=\"display:inline-block;width:200%;height:200%;font-size:16px;max-width:none;\";this.b.appendChild(this.h);this.c.appendChild(this.f);this.a.appendChild(this.b);this.a.appendChild(this.c)}\r\n  function t(a,b){a.a.style.cssText=\"max-width:none;min-width:20px;min-height:20px;display:inline-block;overflow:hidden;position:absolute;width:auto;margin:0;padding:0;top:-999px;white-space:nowrap;font-synthesis:none;font:\"+b+\";\"}function y(a){var b=a.a.offsetWidth,c=b+100;a.f.style.width=c+\"px\";a.c.scrollLeft=c;a.b.scrollLeft=a.b.scrollWidth+100;return a.g!==b?(a.g=b,!0):!1}function z(a,b){function c(){var a=k;y(a)&&a.a.parentNode&&b(a.g)}var k=a;l(a.b,c);l(a.c,c);y(a)};function A(a,b){var c=b||{};this.family=a;this.style=c.style||\"normal\";this.weight=c.weight||\"normal\";this.stretch=c.stretch||\"normal\"}var B=null,C=null,E=null,F=null;function G(){if(null===C)if(J()&&/Apple/.test(window.navigator.vendor)){var a=/AppleWebKit\\/([0-9]+)(?:\\.([0-9]+))(?:\\.([0-9]+))/.exec(window.navigator.userAgent);C=!!a&&603>parseInt(a[1],10)}else C=!1;return C}function J(){null===F&&(F=!!document.fonts);return F}\r\n  function K(){if(null===E){var a=document.createElement(\"div\");try{a.style.font=\"condensed 100px sans-serif\"}catch(b){}E=\"\"!==a.style.font}return E}function L(a,b){return[a.style,a.weight,K()?a.stretch:\"\",\"100px\",b].join(\" \")}\r\n  A.prototype.load=function(a,b){var c=this,k=a||\"BESbswy\",q=0,D=b||3E3,H=(new Date).getTime();return new Promise(function(a,b){if(J()&&!G()){var M=new Promise(function(a,b){function e(){(new Date).getTime()-H>=D?b():document.fonts.load(L(c,'\"'+c.family+'\"'),k).then(function(c){1<=c.length?a():setTimeout(e,25)},function(){b()})}e()}),N=new Promise(function(a,c){q=setTimeout(c,D)});Promise.race([N,M]).then(function(){clearTimeout(q);a(c)},function(){b(c)})}else m(function(){function u(){var b;if(b=-1!=\r\n      f&&-1!=g||-1!=f&&-1!=h||-1!=g&&-1!=h)(b=f!=g&&f!=h&&g!=h)||(null===B&&(b=/AppleWebKit\\/([0-9]+)(?:\\.([0-9]+))/.exec(window.navigator.userAgent),B=!!b&&(536>parseInt(b[1],10)||536===parseInt(b[1],10)&&11>=parseInt(b[2],10))),b=B&&(f==v&&g==v&&h==v||f==w&&g==w&&h==w||f==x&&g==x&&h==x)),b=!b;b&&(d.parentNode&&d.parentNode.removeChild(d),clearTimeout(q),a(c))}function I(){if((new Date).getTime()-H>=D)d.parentNode&&d.parentNode.removeChild(d),b(c);else{var a=document.hidden;if(!0===a||void 0===a)f=e.a.offsetWidth,\r\n    g=n.a.offsetWidth,h=p.a.offsetWidth,u();q=setTimeout(I,50)}}var e=new r(k),n=new r(k),p=new r(k),f=-1,g=-1,h=-1,v=-1,w=-1,x=-1,d=document.createElement(\"div\");d.dir=\"ltr\";t(e,L(c,\"sans-serif\"));t(n,L(c,\"serif\"));t(p,L(c,\"monospace\"));d.appendChild(e.a);d.appendChild(n.a);d.appendChild(p.a);document.body.appendChild(d);v=e.a.offsetWidth;w=n.a.offsetWidth;x=p.a.offsetWidth;I();z(e,function(a){f=a;u()});t(e,L(c,'\"'+c.family+'\",sans-serif'));z(n,function(a){g=a;u()});t(n,L(c,'\"'+c.family+'\",serif'));\r\n    z(p,function(a){h=a;u()});t(p,L(c,'\"'+c.family+'\",monospace'))})})};\"object\"===typeof module?module.exports=A:(window.FontFaceObserver=A,window.FontFaceObserver.prototype.load=A.prototype.load);}());\r\n\r\n\r\n;(function() {\r\n  \"use strict\";function updateLocalStorage(){try{localStorage.setItem(\"ebay-font\",FONT_CLASS_NAME)}catch(e){}}function isFontFaceSetCompatible(){var e=fontFaceSet&&fontFaceSet.load;if(e&&/Apple/.test(window.navigator.vendor)){var t=/AppleWebKit\\/([0-9]+)(?:\\.([0-9]+))(?:\\.([0-9]+))/.exec(window.navigator.userAgent);e=!(t&&parseInt(t[1],10)<603)}return e}function loadFont(){isFontFaceSetCompatible()?(fontFaceSet.load(\"1em Market Sans\"),fontFaceSet.load(\"bold 1em Market Sans\"),fontFaceSet.ready.then(updateLocalStorage)):lassoLoader(\"font-async-observer\",function(e){if(!e){var t=new FontFaceObserver(\"Market Sans\"),a=new FontFaceObserver(\"Market Sans\",{weight:\"bold\"});Promise.all([t.load(),a.load()]).then(updateLocalStorage)}})}function isFontLoaded(){return\"fontDisplay\"in document.documentElement.style||localStorage&&localStorage.getItem(\"ebay-font\")===FONT_CLASS_NAME}function init(){isFontLoaded()||window.addEventListener(\"load\",function(){requestAnimationFrame?requestAnimationFrame(loadFont):loadFont()})}var lassoLoader=function(e,t){t()},fontFaceSet=document.fonts,FONT_CLASS_NAME=\"font-marketsans\";init();\r\n}());\r\n","function initMaps(opts) {\r\n\r\n\topts = $.extend({\r\n\t\tmap: null,\r\n\t\tzoom: 11,\r\n\t\tcenter: [],\r\n\t\tcoords: [],\r\n\t\tpopup: false,\r\n\t\tcallback: function () { }\r\n\t}, opts);\r\n\r\n\tif (!opts.map) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvar MyBalloonContentLayout;\r\n\tvar MyBalloonLayout;\r\n\tvar myPlacemark;\r\n\r\n\tvar myMap = new ymaps.Map(opts.map, {\r\n\t\tcenter: opts.center,\r\n\t\tzoom: opts.zoom\r\n\t});\r\n\r\n\tmyMap.controls\r\n\t\t.remove('mapTools')\r\n\t\t.remove('typeSelector')\r\n\t\t.remove('smallZoomControl')\r\n\t\t.remove('scaleLine')\r\n\t\t.remove('miniMap')\r\n\t\t.remove('searchControl')\r\n\t\t// .remove('zoomControl')\r\n\t\t.remove('trafficControl')\r\n\t\t.remove('mapTools');\r\n\r\n\tif (/Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || screen.width < 768) {\r\n\t\tmyMap.behaviors.disable('drag');\r\n\t}\r\n\r\n\tfor (var i = 0, l = opts.coords.length; i < l; i += 1) {\r\n\r\n\t\tif (opts.popup) {\r\n\r\n\t\t\tMyBalloonLayout = ymaps.templateLayoutFactory.createClass(\r\n\t\t\t\t'<div class=\"map-popup\">' +\r\n\t\t\t\t'<div class=\"map-popup__close\">&times;</div>' +\r\n\t\t\t\t'<div class=\"map-popup__arrow\"></div>' +\r\n\t\t\t\t'<div class=\"map-popup__inner\">' +\r\n\t\t\t\t'$[[options.contentLayout observeSize minWidth=230 maxWidth=230 maxHeight=350]]' +\r\n\t\t\t\t'</div>' +\r\n\t\t\t\t'</div>', {\r\n\t\t\t\t\t/**\r\n\t\t\t\t\t * Строит экземпляр макета на основе шаблона и добавляет его в родительский HTML-элемент.\r\n\t\t\t\t\t * @see https://api.yandex.ru/maps/doc/jsapi/2.1/ref/reference/layout.templateBased.Base.xml#build\r\n\t\t\t\t\t * @function\r\n\t\t\t\t\t * @name build\r\n\t\t\t\t\t */\r\n\t\t\t\t\tbuild: function () {\r\n\t\t\t\t\t\tthis.constructor.superclass.build.call(this);\r\n\r\n\t\t\t\t\t\tthis._$element = $('.map-popup', this.getParentElement());\r\n\r\n\t\t\t\t\t\tthis.applyElementOffset();\r\n\r\n\t\t\t\t\t\tthis._$element.find('.map-popup__close')\r\n\t\t\t\t\t\t\t.on('click', $.proxy(this.onCloseClick, this));\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t/**\r\n\t\t\t\t\t * Удаляет содержимое макета из DOM.\r\n\t\t\t\t\t * @see https://api.yandex.ru/maps/doc/jsapi/2.1/ref/reference/layout.templateBased.Base.xml#clear\r\n\t\t\t\t\t * @function\r\n\t\t\t\t\t * @name clear\r\n\t\t\t\t\t */\r\n\t\t\t\t\tclear: function () {\r\n\t\t\t\t\t\tthis._$element.find('.map-popup__close')\r\n\t\t\t\t\t\t\t.off('click');\r\n\r\n\t\t\t\t\t\tthis.constructor.superclass.clear.call(this);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t/**\r\n\t\t\t\t\t * Метод будет вызван системой шаблонов АПИ при изменении размеров вложенного макета.\r\n\t\t\t\t\t * @see https://api.yandex.ru/maps/doc/jsapi/2.1/ref/reference/IBalloonLayout.xml#event-userclose\r\n\t\t\t\t\t * @function\r\n\t\t\t\t\t * @name onSublayoutSizeChange\r\n\t\t\t\t\t */\r\n\t\t\t\t\tonSublayoutSizeChange: function () {\r\n\t\t\t\t\t\tMyBalloonLayout.superclass.onSublayoutSizeChange.apply(this, arguments);\r\n\r\n\t\t\t\t\t\tif (!this._isElement(this._$element)) {\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tthis.applyElementOffset();\r\n\r\n\t\t\t\t\t\tthis.events.fire('shapechange');\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t/**\r\n\t\t\t\t\t * Сдвигаем балун, чтобы \"хвостик\" указывал на точку привязки.\r\n\t\t\t\t\t * @see https://api.yandex.ru/maps/doc/jsapi/2.1/ref/reference/IBalloonLayout.xml#event-userclose\r\n\t\t\t\t\t * @function\r\n\t\t\t\t\t * @name applyElementOffset\r\n\t\t\t\t\t */\r\n\t\t\t\t\tapplyElementOffset: function () {\r\n\t\t\t\t\t\tthis._$element.css({\r\n\t\t\t\t\t\t\tleft: -(this._$element[0].offsetWidth / 2),\r\n\t\t\t\t\t\t\ttop: -(this._$element[0].offsetHeight + this._$element.find('.map-popup__arrow')[0].offsetHeight)\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t/**\r\n\t\t\t\t\t * Закрывает балун при клике на крестик, кидая событие \"userclose\" на макете.\r\n\t\t\t\t\t * @see https://api.yandex.ru/maps/doc/jsapi/2.1/ref/reference/IBalloonLayout.xml#event-userclose\r\n\t\t\t\t\t * @function\r\n\t\t\t\t\t * @name onCloseClick\r\n\t\t\t\t\t */\r\n\t\t\t\t\tonCloseClick: function (e) {\r\n\t\t\t\t\t\te.preventDefault();\r\n\r\n\t\t\t\t\t\tthis.events.fire('userclose');\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t/**\r\n\t\t\t\t\t * Используется для автопозиционирования (balloonAutoPan).\r\n\t\t\t\t\t * @see https://api.yandex.ru/maps/doc/jsapi/2.1/ref/reference/ILayout.xml#getClientBounds\r\n\t\t\t\t\t * @function\r\n\t\t\t\t\t * @name getClientBounds\r\n\t\t\t\t\t * @returns {Number[][]} Координаты левого верхнего и правого нижнего углов шаблона относительно точки привязки.\r\n\t\t\t\t\t */\r\n\t\t\t\t\tgetShape: function () {\r\n\t\t\t\t\t\tif (!this._isElement(this._$element)) {\r\n\t\t\t\t\t\t\treturn MyBalloonLayout.superclass.getShape.call(this);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar position = this._$element.position();\r\n\r\n\t\t\t\t\t\treturn new ymaps.shape.Rectangle(new ymaps.geometry.pixel.Rectangle([\r\n\t\t\t\t\t\t\t[position.left, position.top - 50], [\r\n\t\t\t\t\t\t\t\tposition.left + this._$element[0].offsetWidth,\r\n\t\t\t\t\t\t\t\tposition.top + this._$element[0].offsetHeight + this._$element.find('.map-popup__arrow')[0].offsetHeight\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t]));\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t/**\r\n\t\t\t\t\t * Проверяем наличие элемента (в ИЕ и Опере его еще может не быть).\r\n\t\t\t\t\t * @function\r\n\t\t\t\t\t * @private\r\n\t\t\t\t\t * @name _isElement\r\n\t\t\t\t\t * @param {jQuery} [element] Элемент.\r\n\t\t\t\t\t * @returns {Boolean} Флаг наличия.\r\n\t\t\t\t\t */\r\n\t\t\t\t\t_isElement: function (element) {\r\n\t\t\t\t\t\treturn element && element[0] && element.find('.map-popup__arrow')[0];\r\n\t\t\t\t\t}\r\n\t\t\t\t}),\r\n\r\n\t\t\t\t// Создание вложенного макета содержимого балуна.\r\n\t\t\t\tMyBalloonContentLayout = ymaps.templateLayoutFactory.createClass(\r\n\t\t\t\t\t'<h3 class=\"map-popup__title\">$[properties.balloonHeader]</h3>' +\r\n\t\t\t\t\t'<div class=\"map-popup__text\">$[properties.balloonContent]</div>'\r\n\t\t\t\t),\r\n\r\n\t\t\t\t// Создание метки с пользовательским макетом балуна.\r\n\t\t\t\tmyPlacemark = new ymaps.Placemark([opts.coords[i].x, opts.coords[i].y], {\r\n\t\t\t\t\tballoonHeader: opts.coords[i].title,\r\n\t\t\t\t\tballoonContent: opts.coords[i].content\r\n\t\t\t\t}, {\r\n\t\t\t\t\t\tballoonShadow: false,\r\n\t\t\t\t\t\tballoonLayout: MyBalloonLayout,\r\n\t\t\t\t\t\tballoonContentLayout: MyBalloonContentLayout,\r\n\t\t\t\t\t\tballoonPanelMaxMapArea: 0,\r\n\t\t\t\t\t\t// Не скрываем иконку при открытом балуне.\r\n\t\t\t\t\t\thideIconOnBalloonOpen: true,\r\n\t\t\t\t\t\t// И дополнительно смещаем балун, для открытия над иконкой.\r\n\t\t\t\t\t\tballoonOffset: [0, -40],\r\n\t\t\t\t\t\ticonLayout: 'default#image',\r\n\t\t\t\t\t\ticonImageHref: '/local/templates/.default/mockup/templates/main/build/images/lens-sign-blue.svg',\r\n\t\t\t\t\t\t// iconImageHref: '../images/lens-sign-blue.svg',\r\n\t\t\t\t\t\ticonImageSize: [52, 46],\r\n\t\t\t\t\t\ticonImageOffset: [-26, -46]\r\n\t\t\t\t\t});\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmyPlacemark = new ymaps.Placemark([opts.coords[i].x, opts.coords[i].y], {}, {\r\n\t\t\t\t// Не скрываем иконку при открытом балуне.\r\n\t\t\t\thideIconOnBalloonOpen: false,\r\n\t\t\t\t// И дополнительно смещаем балун, для открытия над иконкой.\r\n\t\t\t\tballoonOffset: [0, -40],\r\n\t\t\t\ticonLayout: 'default#image',\r\n\t\t\t\ticonImageHref: '/local/templates/.default/mockup/templates/main/build/images/lens-sign-blue.svg',\r\n\t\t\t\t// iconImageHref: '../images/lens-sign-blue.svg',\r\n\t\t\t\ticonImageSize: [52, 46],\r\n\t\t\t\ticonImageOffset: [-26, -46]\r\n\t\t\t});\r\n\r\n\t\t}\r\n\r\n\t\tmyMap.geoObjects.add(myPlacemark);\r\n\r\n\t\tif (opts.callback) {\r\n\t\t\topts.callback();\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nymaps.ready(function () {\r\n\r\n\t// contacts page\r\n\t(function () {\r\n\r\n\t\tvar maps = document.querySelectorAll('.js-contact__map');\r\n\r\n\t\t$(maps).each(function () {\r\n\r\n\t\t\tvar _coords = [];\r\n\t\t\tvar _tmp = (this.getAttribute('data-coords')).split(',');\r\n\r\n\t\t\t_coords.push({\r\n\t\t\t\tx: parseFloat(_tmp[0]),\r\n\t\t\t\ty: parseFloat(_tmp[1])\r\n\t\t\t});\r\n\r\n\t\t\tinitMaps({\r\n\t\t\t\tmap: this,\r\n\t\t\t\tzoom: 17,\r\n\t\t\t\tcenter: [_coords[0].x, _coords[0].y],\r\n\t\t\t\tcoords: _coords\r\n\t\t\t});\r\n\r\n\t\t});\r\n\r\n\t})();\r\n\r\n\t// main page\r\n\t(function () {\r\n\r\n\t\tvar mainMap = document.querySelector('#js-diagnostics__map');\r\n\t\tif (!mainMap) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tvar _coords = [];\r\n\t\tvar _center = [55.756251, 49.210635];\r\n\r\n\t\t_coords.push({\r\n\t\t\tx: 55.756881,\r\n\t\t\ty: 49.210458,\r\n\t\t\ttitle: 'ТЦ Внуково Аутлет Вилладж 1',\r\n\t\t\tcontent: 'Киевское ш. 8 км. от МКАД, пос.Московский, дер.Лапшинка 8к1<div class=\"map-popup__time\">8(495) 280-70 - 41</div><a href=\"#\" class=\"map-popup__link\">Запись на проверку зрения</a>'\r\n\t\t});\r\n\r\n\t\t_coords.push({\r\n\t\t\tx: 55.756176,\r\n\t\t\ty: 49.213913,\r\n\t\t\ttitle: 'ТЦ Внуково Аутлет Вилладж 2',\r\n\t\t\tcontent: 'Киевское ш. 8 км. от МКАД, пос.Московский, дер.Лапшинка 8к1<div class=\"map-popup__time\">8(495) 280-70 - 41</div><a href=\"#\" class=\"map-popup__link\">Запись на проверку зрения</a>'\r\n\t\t});\r\n\r\n\t\t_coords.push({\r\n\t\t\tx: 55.754987,\r\n\t\t\ty: 49.210254,\r\n\t\t\ttitle: 'ТЦ Внуково Аутлет Вилладж 3',\r\n\t\t\tcontent: 'Киевское ш. 8 км. от МКАД, пос.Московский, дер.Лапшинка 8к1<div class=\"map-popup__time\">8(495) 280-70 - 41</div><a href=\"#\" class=\"map-popup__link\">Запись на проверку зрения</a>'\r\n\t\t});\r\n\r\n\t\tinitMaps({\r\n\t\t\tmap: mainMap,\r\n\t\t\tzoom: 15,\r\n\t\t\tcenter: _center,\r\n\t\t\tcoords: _coords,\r\n\t\t\tpopup: true\r\n\t\t});\r\n\r\n\t})();\r\n\r\n\t//appointment page\r\n\t(function () {\r\n\r\n\t\tvar mainMap = document.querySelector('#js-appointment__map');\r\n\t\tif (!mainMap) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tvar _coords = [];\r\n\t\tvar _center = [55.756251, 49.210635];\r\n\r\n\t\t_coords.push({\r\n\t\t\tx: 55.756881,\r\n\t\t\ty: 49.210458,\r\n\t\t\ttitle: 'ТЦ Внуково Аутлет Вилладж 1',\r\n\t\t\tcontent: 'Киевское ш. 8 км. от МКАД, пос.Московский, дер.Лапшинка 8к1<div class=\"map-popup__time\">8(495) 280-70 - 41</div><a href=\"#\" class=\"map-popup__link\">Запись на проверку зрения</a>'\r\n\t\t});\r\n\r\n\t\t_coords.push({\r\n\t\t\tx: 55.756176,\r\n\t\t\ty: 49.213913,\r\n\t\t\ttitle: 'ТЦ Внуково Аутлет Вилладж 2',\r\n\t\t\tcontent: 'Киевское ш. 8 км. от МКАД, пос.Московский, дер.Лапшинка 8к1<div class=\"map-popup__time\">8(495) 280-70 - 41</div><a href=\"#\" class=\"map-popup__link\">Запись на проверку зрения</a>'\r\n\t\t});\r\n\r\n\t\t_coords.push({\r\n\t\t\tx: 55.754987,\r\n\t\t\ty: 49.210254,\r\n\t\t\ttitle: 'ТЦ Внуково Аутлет Вилладж 3',\r\n\t\t\tcontent: 'Киевское ш. 8 км. от МКАД, пос.Московский, дер.Лапшинка 8к1<div class=\"map-popup__time\">8(495) 280-70 - 41</div><a href=\"#\" class=\"map-popup__link\">Запись на проверку зрения</a>'\r\n\t\t});\r\n\r\n\t\tinitMaps({\r\n\t\t\tmap: mainMap,\r\n\t\t\tzoom: 15,\r\n\t\t\tcenter: _center,\r\n\t\t\tcoords: _coords,\r\n\t\t\tpopup: true\r\n\t\t});\r\n\r\n\t})();\r\n\r\n});","//Доступный hamburger https://foxland.fi/simple-accessible-svg-menu-hamburger-animation\r\nfunction hamburger(element, menu) {\r\n\tvar button = document.getElementById(element),\r\n\t\tmenu = document.getElementById(menu);\r\n\tbutton.onclick = function () {\r\n\t\t// Toggle class \"opened\". Set also aria-expanded to true or false.\r\n\t\tif (-1 !== button.className.indexOf('opened')) {\r\n\t\t\tbutton.className = button.className.replace(' opened', '');\r\n\t\t\tbutton.setAttribute('aria-expanded', 'false');\r\n\t\t\tmenu.className = menu.className.replace(' active', '');\r\n\t\t\tmenu.setAttribute('aria-expanded', 'false');\r\n\t\t} else {\r\n\t\t\tbutton.className += ' opened';\r\n\t\t\tbutton.setAttribute('aria-expanded', 'true');\r\n\t\t\tmenu.className += ' active';\r\n\t\t\tmenu.setAttribute('aria-expanded', 'true');\r\n\t\t}\r\n\t};\r\n}\r\n\r\n$(document).ready(function () {\r\n\r\n\twindow.globalPopup = new Popup();\r\n\r\n\t// $(\".js-combox\").combox({\r\n\t// \tstartFn: function(li, index, combox) {\r\n\r\n\t// \t\tthis.input = combox.getElementsByTagName(\"input\")[0];\r\n\r\n\t// \t\tthis.input.value = li.getAttribute(\"value\");\r\n\r\n\t// \t},\r\n\t// \tchangeFn: function(li, index, combox) {\r\n\r\n\t// \t\tvar _this = this;\r\n\r\n\t// \t\tthis.input.value = li.getAttribute(\"value\");\r\n\r\n\t// \t}\r\n\t// });\r\n\r\n\thamburger('js-hamburger', \"js-menu\");\r\n\r\n\t$(\"[type=tel]\").inputmask(\"+7 (999) 999-99-99\");\r\n\r\n\t// Прибивка адаптивного футера к низу\r\n\t(function (footerSelector, wrapperSelector) {\r\n\r\n\t\tvar footer = document.querySelector(footerSelector);\r\n\t\tvar wrapper = document.querySelector(wrapperSelector);\r\n\t\tvar height;\r\n\t\tvar setSize;\r\n\r\n\t\tif (!wrapper || !footer) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tsetSize = function () {\r\n\r\n\t\t\theight = footer.offsetHeight;\r\n\r\n\t\t\twrapper.style.paddingBottom = height + 'px';\r\n\t\t\tfooter.style.marginTop = (height * (-1)) + 'px';\r\n\r\n\t\t}\r\n\r\n\t\tsetSize();\r\n\r\n\t\twindow.addEventListener('resize', setSize, false);\r\n\r\n\t})('#js-footer', '#js-wrapper');\r\n\r\n});\r\n"]}